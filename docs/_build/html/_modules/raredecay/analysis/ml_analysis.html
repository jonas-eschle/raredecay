

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>raredecay.analysis.ml_analysis &mdash; raredecay 1.0a documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="raredecay 1.0a documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> raredecay
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../raredecay.html">Raredecay Analysis Package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">raredecay</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>raredecay.analysis.ml_analysis</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for raredecay.analysis.ml_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sat Mar 26 11:29:01 2016</span>

<span class="sd">@author: Jonas Eschle &quot;Mayou36&quot;</span>

<span class="sd">The Machine Learning Analysis module consists of machine-learning functions</span>
<span class="sd">which are mostly wrappers around already existing algorithms. The expected</span>
<span class="sd">format of the data is a *HEPDataStorage*.</span>

<span class="sd">The functions serve as basic tools, which do already a lot of the work.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">hep_ml.reweight</span>
<span class="c1">#from rep.metaml import ClassifiersFactory</span>
<span class="kn">from</span> <span class="nn">rep.utils</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">rep.data</span> <span class="k">import</span> <span class="n">LabeledDataStorage</span>

<span class="c1"># classifier imports</span>
<span class="kn">from</span> <span class="nn">rep.estimators</span> <span class="k">import</span> <span class="n">SklearnClassifier</span><span class="p">,</span> <span class="n">XGBoostClassifier</span><span class="p">,</span> <span class="n">TMVAClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">GradientBoostingClassifier</span><span class="p">,</span> <span class="n">RandomForestClassifier</span><span class="p">,</span> <span class="n">ExtraTreesClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">AdaBoostClassifier</span><span class="p">,</span> <span class="n">VotingClassifier</span>
<span class="kn">from</span> <span class="nn">rep.estimators.theanets</span> <span class="k">import</span> <span class="n">TheanetsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="k">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">rep.estimators.interface</span> <span class="k">import</span> <span class="n">Classifier</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="k">import</span> <span class="n">BaseEstimator</span>

<span class="c1"># scoring and validation</span>
<span class="kn">from</span> <span class="nn">rep.metaml.folding</span> <span class="k">import</span> <span class="n">FoldingClassifier</span>
<span class="kn">from</span> <span class="nn">rep.report</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="kn">from</span> <span class="nn">rep.report.classification</span> <span class="k">import</span> <span class="n">ClassificationReport</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">classification_report</span>

<span class="c1"># Hyperparameter optimization</span>
<span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="k">import</span> <span class="n">GridOptimalSearchCV</span><span class="p">,</span> <span class="n">FoldingScorer</span><span class="p">,</span> <span class="n">RandomParameterOptimizer</span><span class="p">,</span> <span class="n">SubgridParameterOptimizer</span>
<span class="kn">from</span> <span class="nn">rep.metaml.gridsearch</span> <span class="k">import</span> <span class="n">RegressionParameterOptimizer</span><span class="p">,</span> <span class="n">AnnealingParameterOptimizer</span>

<span class="kn">from</span> <span class="nn">raredecay.tools</span> <span class="k">import</span> <span class="n">dev_tool</span><span class="p">,</span> <span class="n">data_tools</span><span class="p">,</span> <span class="n">data_storage</span>
<span class="kn">from</span> <span class="nn">raredecay</span> <span class="k">import</span> <span class="n">globals_</span>
<span class="kn">from</span> <span class="nn">raredecay.globals_</span> <span class="k">import</span> <span class="n">out</span>

<span class="c1"># import configuration</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">from</span> <span class="nn">raredecay</span> <span class="k">import</span> <span class="n">meta_config</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">run_config</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">make_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">logger_cfg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">weight_original</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conv_ori_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">conv_tar_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the concatenated data, weights and labels for classifier training.</span>

<span class="sd">     Differs to only *make_dataset* from the HEPDataStorage by providing the</span>
<span class="sd">     possibility of using other weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make temporary weights if specific weights are given as parameters</span>
    <span class="n">temp_ori_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">temp_tar_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">weight_original</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">temp_ori_weights</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weight_original</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">weight_target</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">temp_tar_weights</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
        <span class="n">target_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weight_target</span><span class="p">)</span>

    <span class="c1"># create the data, target and weights</span>
    <span class="n">data_out</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                          <span class="n">targets_from_data</span><span class="o">=</span><span class="n">target_from_data</span><span class="p">,</span>
                                          <span class="n">weights_as_events</span><span class="o">=</span><span class="n">conv_ori_weights</span><span class="p">,</span>
                                          <span class="n">weights_as_events_2</span><span class="o">=</span><span class="n">conv_tar_weights</span><span class="p">,</span>
                                          <span class="n">weights_ratio</span><span class="o">=</span><span class="n">weights_ratio</span><span class="p">)</span>

    <span class="c1"># reassign weights if specific weights have been used</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">temp_ori_weights</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_ori_weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">temp_tar_weights</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_tar_weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_out</span>


<div class="viewcode-block" id="make_clf"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.make_clf">[docs]</a><span class="k">def</span> <span class="nf">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dict_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a classifier-dict. Takes a str, config-dict or clf-dict or clf</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clf : dict or str or sklearn/REP-classifier</span>
<span class="sd">        There are several ways to pass the classifier to the function.</span>

<span class="sd">        - Pure classifier: You can pass a classifier to the method,</span>
<span class="sd">          either a scikit-learn or a REP classifier.</span>
<span class="sd">        - Classifier with name: you can name your classifier by either:</span>

<span class="sd">          - using a dict with {&#39;my_clf_1&#39;: clf}</span>
<span class="sd">          - using a dict with {&#39;name&#39;: &#39;my_clf_1&#39;, &#39;clf&#39;: clf}</span>
<span class="sd">            where clf referes to the classifier and &#39;my_clf_1&#39; can be any name.</span>
<span class="sd">        - Configuration for a clf: Instead of instantiating the clf outside,</span>
<span class="sd">          you can also pass a configuration-dictionary. This has to look like:</span>

<span class="sd">          - {&#39;clf_type&#39;: config-dict, &#39;name&#39;: &#39;my_clf_1&#39;} (name is optional)</span>
<span class="sd">            whereas &#39;clf_type&#39; has to be any of the implemented clf-types like</span>
<span class="sd">            &#39;xgb&#39;, &#39;rdf&#39;, &#39;ada&#39; etc.</span>
<span class="sd">        - Get a standard-clf: providing a string refering to an implemented</span>
<span class="sd">          clf-type, you will get a classifier using the configuration in</span>
<span class="sd">          :py:mod:`~raredecay.meta_config`</span>

<span class="sd">    n_cpu : int &gt; -1 or None</span>
<span class="sd">        The number of cpus to use for this classifier. If the classifier is not</span>
<span class="sd">        parallelizable, an according *parallel_profile* (also see in REP-docs)</span>
<span class="sd">        will be created; &#39;threads-n&#39; with n the number of cpus specified before.</span>
<span class="sd">    dict_only : boolean</span>
<span class="sd">        If True, only a dictionary will be returned containing the name, config,</span>
<span class="sd">        clf_type and parallel_profile, n_cpu.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        A dictionary containing the name (&#39;name&#39;) of the classifier as well</span>
<span class="sd">        as the classifier itself (&#39;clf&#39;). If *dict_only* is True, no clf will</span>
<span class="sd">        be returned but a &#39;clf_type&#39; as well as a &#39;config&#39; key.</span>
<span class="sd">        Additionally, there are more values that can be contained: if a</span>
<span class="sd">        configuration and not an already instantiated clf is given:</span>

<span class="sd">        - **parallel_profile**: the parallel-profile (for different REP-functions)</span>
<span class="sd">          which is set according to the n_cpus entered as well as the n_cpus</span>
<span class="sd">          used. If n cpus should be used, the classifier takes, the profile</span>
<span class="sd">          will be None. If the classifier is using only 1 cpu, the profile will</span>
<span class="sd">          be &#39;threads-n&#39; with n = n_cpus.</span>
<span class="sd">        - **n_cpus**: The number of cpus used in the classifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__IMPLEMENTED_CLFS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="s1">&#39;rdf&#39;</span><span class="p">,</span> <span class="s1">&#39;nn&#39;</span><span class="p">,</span> <span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="s1">&#39;tmva&#39;</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span>  <span class="c1"># make sure not to change the argument given</span>

    <span class="c1"># test if input is classifier, create dict</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clf&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">}</span>

    <span class="c1"># if clf is a string only, create dict with only the type specified</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">clf</span> <span class="ow">in</span> <span class="n">__IMPLEMENTED_CLFS</span><span class="p">,</span> <span class="s2">&quot;clf not implemented (yet. Make an issue;) )&quot;</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clf_type&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">}</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Wrong data format of classifier...&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_cpu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span>
    <span class="n">n_cpu</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n_cpu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n_cpu</span>
    <span class="k">if</span> <span class="n">n_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">globals_</span><span class="o">.</span><span class="n">free_cpus</span><span class="p">()</span>

    <span class="c1"># if input is dict containing a clf, make sure it&#39;s a Sklearn one</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">):</span>
            <span class="n">classifier</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">classifier</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">classifier</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;clf&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clf</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;clf_type&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">imp_clf</span> <span class="ow">in</span> <span class="n">__IMPLEMENTED_CLFS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clf</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">imp_clf</span><span class="p">):</span>
                    <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp_clf</span>
                    <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="n">imp_clf</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clf</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;clf_type&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid classifier, not implemented&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clf</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span>
        <span class="n">default_clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">clf_type</span><span class="o">=</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">],</span>
            <span class="n">name</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_NAME</span><span class="p">[</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]],</span>
            <span class="n">config</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_CONFIG</span><span class="p">[</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]],</span>
        <span class="p">)</span>

        <span class="n">clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">default_clf</span><span class="p">,</span> <span class="o">**</span><span class="n">clf</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;xgb&#39;</span><span class="p">:</span>
            <span class="c1"># update config dict with parallel-variables and random state</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nthreads</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>  <span class="c1"># overwrite entries</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">XGBoostClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;tmva&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">TMVAClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;gb&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rdf&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">432</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ada&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">43</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">base_estimator</span><span class="o">=</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span>
                                    <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span> <span class="o">+</span> <span class="mi">29</span><span class="p">),</span> <span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">919</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rdf&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">432</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">use_gpu</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">43</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">TheanetsClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>

        <span class="c1"># assign classifier to output dict</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf_tmp</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dict_only</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;clf&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">clf_tmp</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span>
        <span class="c1"># add parallel information</span>
        <span class="k">if</span> <span class="n">serial_clf</span> <span class="ow">and</span> <span class="n">n_cpu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;threads-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_cpu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_cpu</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="backward_feature_elimination"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.backward_feature_elimination">[docs]</a><span class="k">def</span> <span class="nf">backward_feature_elimination</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                 <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_feature_elimination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">max_difference_to_best</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">,</span>
                                 <span class="n">take_target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Train and score on each feature subset, eliminating features backwards.</span>

<span class="sd">    To know, which features make a big impact on the training of the clf and</span>
<span class="sd">    which don&#39;t, there are several techniques to find out. The most reliable,</span>
<span class="sd">    but also cost-intensive one, seems to be the backward feature elimination.</span>
<span class="sd">    A classifier gets trained first on all the features and is validated with</span>
<span class="sd">    the KFold-technique and the ROC AUC. Then, a feature is removed and the</span>
<span class="sd">    classifier is trained and tested again. This is done for all features once.</span>
<span class="sd">    The one where the auc drops the least is then removed and the next round</span>
<span class="sd">    starts from the beginning but with one feature less.</span>

<span class="sd">    The function ends either if:</span>

<span class="sd">    - no features are left</span>
<span class="sd">    - max_feature_elimination features have been eliminated</span>
<span class="sd">    - the difference between the most useless features auc and the best</span>
<span class="sd">      (the run done with all features in the beginning) is higher then</span>
<span class="sd">      max_difference_to_best</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data</span>
<span class="sd">    target_data : HEPDataStorage</span>
<span class="sd">        The target data</span>
<span class="sd">    clf : str {&#39;xgb, &#39;rdf, &#39;erf&#39;, &#39;gb&#39;, &#39;ada&#39;, &#39;nn&#39;} or config-dict</span>
<span class="sd">        For possible options, see also :py:func:`~raredecay.ml_analysis.make_clf()`</span>
<span class="sd">    n_folds : int &gt; 1</span>
<span class="sd">        How many folds you want to split your data in when doing KFold-splits</span>
<span class="sd">        to measure the performance of the classifier.</span>
<span class="sd">    features : list(str, str, str,...)</span>
<span class="sd">        List of strings containing the features/columns to be used for the</span>
<span class="sd">        hyper-optimization or feature selection.</span>
<span class="sd">    max_feature_elimination : int &gt;= 1</span>
<span class="sd">        How many features should be eliminated before it surely stopps</span>
<span class="sd">    max_difference_to_best : float</span>
<span class="sd">        The maximum difference between the &quot;worst&quot; features auc and the best</span>
<span class="sd">        (with all features) auc before it stopps.</span>
<span class="sd">    take_target_from_data : boolean</span>
<span class="sd">        Old, will be removed. Use if target-data == None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        Return a dictionary containing the evaluation:</span>
<span class="sd">        - **&#39;roc_auc&#39;** : an ordered-dict with the feature that was removed and</span>
<span class="sd">          the roc auc evaluated without that feature.</span>
<span class="sd">        - **&#39;scores&#39;** : All the roc auc with every feature removed once.</span>
<span class="sd">          Basically a pandas DataFrame containing all results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize variables and setting defaults</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># means: no time measurement on the way</span>
    <span class="n">available_time</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># start timer if time-limit is given</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">max_feature_elimination</span> <span class="o">=</span> <span class="n">max_feature_elimination</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Wrong time-format. Has to be &#39;hhh...hhh:mm&#39; &quot;</span>
        <span class="n">available_time</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error, start_time is &lt;= 0, will cause error later&quot;</span>

    <span class="n">save_fig_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_SAVE_FIG</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">save_fig_cfg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">meta_config</span><span class="o">.</span><span class="n">warning_occured</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Feature not specified as argument to optimize_hyper_parameters.&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;Features for feature-optimization will be taken from data.&quot;</span><span class="p">)</span>
    <span class="c1"># We do not need to create more data than we well test on</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">features</span> <span class="o">!=</span> <span class="p">[],</span> <span class="s2">&quot;No features for optimization found&quot;</span>

    <span class="c1">#TODO: insert time estimation for feature optimization</span>

    <span class="c1"># initialize data</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                      <span class="n">target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">)</span>

    <span class="c1"># initialize clf and parallel_profile</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
    <span class="n">clf_name</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">parallel_profile</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># start backward feature elimination</span>
<span class="c1">#==============================================================================</span>
    <span class="n">selected_features</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>  <span class="c1"># explicit is better than implicit</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Need more then one feature to perform feature selection&quot;</span>

    <span class="c1"># starting feature selection</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Performing feature selection with the classifier&quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span>
                    <span class="s2">&quot;of the features&quot;</span><span class="p">,</span> <span class="n">features</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature selection: Backward elimination&quot;</span><span class="p">)</span>
    <span class="n">original_clf</span> <span class="o">=</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span>
                                     <span class="n">stratified</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">use_stratified_folding</span><span class="p">,</span>
                                     <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">)</span>

    <span class="c1"># &quot;loop-initialization&quot;, get score for all features</span>
    <span class="n">roc_auc</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({})</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">feature</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">selected_features</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">original_clf</span><span class="p">)</span>  <span class="c1"># required, the features attribute can not be changed somehow</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">selected_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">test_on</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">selected_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">max_auc</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">roc_auc</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="s1">&#39;all features&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">max_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;feature importance &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">feature_importance_shuffling</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;feature correlation &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">features_correlation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;ROC curve &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">roc</span><span class="p">(</span><span class="n">physics_notion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Learning curve &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">learning_curve</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">steps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric_label</span><span class="o">=</span><span class="s2">&quot;ROC AUC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

        <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">max_feature_elimination</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># eliminate all except one</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_feature_elimination</span><span class="p">])</span>

    <span class="c1"># do-while python-style (with if-break inside)</span>
    <span class="k">while</span> <span class="n">n_to_eliminate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># initialize variable</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># a surely big initialisation</span>
        <span class="n">n_to_eliminate</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">n_features_left</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span>
        <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_features_left</span><span class="p">)</span>

        <span class="c1"># iterate through the features and remove the ith each time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selected_features</span><span class="p">):</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">original_clf</span><span class="p">)</span>  <span class="c1"># otherwise feature attribute trouble</span>
            <span class="n">temp_features</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">temp_features</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># remove ith feature for testing</span>
            <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">temp_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">test_on</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">temp_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">temp_auc</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">collected_scores</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">temp_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># set time condition</span>
            <span class="k">if</span> <span class="n">available_time</span> <span class="o">&lt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">max_auc</span> <span class="o">-</span> <span class="n">temp_auc</span> <span class="o">&lt;</span> <span class="n">difference</span><span class="p">:</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">max_auc</span> <span class="o">-</span> <span class="n">temp_auc</span>
                <span class="n">temp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">feature</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">temp_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">)}</span>

        <span class="k">if</span> <span class="n">difference</span> <span class="o">&gt;=</span> <span class="n">max_difference_to_best</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">roc_auc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp_dict</span><span class="p">)</span>
            <span class="n">selected_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max_auc</span> <span class="o">=</span> <span class="n">temp_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># set time condition</span>
            <span class="k">if</span> <span class="n">available_time</span> <span class="o">&lt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;roc_auc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">roc_auc</span>


    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">missing_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">collected_scores</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">missing_values</span><span class="p">)</span>
    <span class="n">temp_val</span> <span class="o">=</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;features_tot&#39;</span><span class="p">)</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;auc w/o &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_val</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">collected_scores</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;The collected scores: &quot;</span><span class="p">,</span> <span class="n">collected_scores</span><span class="p">],</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;scores&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collected_scores</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">difference</span> <span class="o">&gt;=</span> <span class="n">max_difference_to_best</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Stopped because difference in roc auc to best was &quot;</span><span class="p">,</span>
                        <span class="s2">&quot;higher then max_difference_to_best&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Next feature would have been: &quot;</span><span class="p">,</span> <span class="n">temp_dict</span><span class="p">],</span>
                        <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Feature elimination stopped because&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;max_feature_elimination was reached (feature or time limit).&quot;</span><span class="p">],</span>
                        <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span>
    <span class="c1"># if all features were removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;All features removed, loop stopped removing because no feature was left&quot;</span><span class="p">],</span>
                        <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span></div>





<div class="viewcode-block" id="optimize_hyper_parameters"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.optimize_hyper_parameters">[docs]</a><span class="k">def</span> <span class="nf">optimize_hyper_parameters</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">n_eval</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">n_checks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">generator_type</span><span class="o">=</span><span class="s1">&#39;subgrid&#39;</span><span class="p">,</span>
                              <span class="n">take_target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimize the hyperparameters of a classifier</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data</span>
<span class="sd">    target_data : HEPDataStorage</span>
<span class="sd">        The target data</span>
<span class="sd">    clf : config-dict</span>
<span class="sd">        For possible options, see also :py:func:`~raredecay.ml_analysis.make_clf()`.</span>
<span class="sd">        The difference is, for the feature you want to have optimised, use an</span>
<span class="sd">        iterable instead of a single value, e.g. &#39;n_estimators&#39;: [1, 2, 3, 4] etc.</span>
<span class="sd">    n_eval : int &gt; 1 or str &quot;hh...hh:mm&quot;</span>
<span class="sd">        How many evaluations should be done; how many points in the</span>
<span class="sd">        hyperparameter-space should be tested. This can either be an integer,</span>
<span class="sd">        which then represents the number of evaluations done or a string in the</span>
<span class="sd">        format of &quot;hours:minutes&quot; (e.g. &quot;3:25&quot;, &quot;1569:01&quot; (quite long...),</span>
<span class="sd">        &quot;0:12&quot;), which represents the approximat time it should take for the</span>
<span class="sd">        hyperparameter-search (**not** the exact upper limit)</span>
<span class="sd">    features : list(str, str, str,...)</span>
<span class="sd">        List of strings containing the features/columns to be used for the</span>
<span class="sd">        hyper-optimization.</span>
<span class="sd">    n_checks : int &gt;= 1</span>
<span class="sd">        Number of checks on *each* KFolded dataset will be done. For example,</span>
<span class="sd">        you split your data into 10 folds, but may only want to train/test on</span>
<span class="sd">        3 different ones.</span>
<span class="sd">    n_folds : int &gt; 1</span>
<span class="sd">        How many folds you want to split your data in when doing train/test</span>
<span class="sd">        sets to measure the performance of the classifier.</span>
<span class="sd">    generator_type : str {&#39;subgrid&#39;, &#39;regression&#39;, &#39;random&#39;}</span>
<span class="sd">        The generator searches the hyper-parameter space. Different generators</span>
<span class="sd">        can be used using different strategies to search for the global maximum.</span>

<span class="sd">        - **subgrid** : For larger grids, first performe search on smaller</span>
<span class="sd">          subgrids to better know the rough topology of the space.</span>
<span class="sd">        - **regression** : using an estimator doing regression on the already</span>
<span class="sd">          known hyper-parameter space points to estimate where to test for</span>
<span class="sd">          the next one.</span>
<span class="sd">        - **random** : Randomly choose points in the hyper-parameter space.</span>
<span class="sd">    take_target_from_data : Boolean</span>
<span class="sd">        OUTDATED; not encouraged to use</span>
<span class="sd">        If True, the target-labeling (the y) will be taken from the data</span>
<span class="sd">        directly and not created. Otherwise, 0 will be assumed for the</span>
<span class="sd">        original_data and 1 for the target_data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize variables and setting defaults</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">save_fig_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_SAVE_FIG</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">save_fig_cfg</span><span class="p">)</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">,</span> <span class="n">dict_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">config_clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span>
    <span class="n">config_clf_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config_clf</span><span class="p">)</span>

    <span class="c1"># Create parameter for clf and hyper-search</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">columns</span>

    <span class="n">grid_param</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">list_param</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">,</span> <span class="s1">&#39;trainers&#39;</span><span class="p">]</span>  <span class="c1"># parameters which are by their nature a list, like nn-layers</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_clf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_param</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">grid_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>



    <span class="c1"># count maximal combinations of parameters</span>
    <span class="n">max_eval</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">n_params</span> <span class="ow">in</span> <span class="n">grid_param</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
        <span class="n">max_eval</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_params</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Maximum possible evaluations: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_eval</span><span class="p">))</span>

    <span class="c1"># get a time estimation and extrapolate to get n_eval</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">max_eval</span><span class="p">):</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="n">n_eval</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_eval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Wrong time-format. Has to be &#39;hhh...hhh:mm&#39; &quot;</span>
        <span class="n">available_time</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_eval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_eval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">start_timer_test</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">min_elapsed_time</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mf">0.005</span> <span class="o">*</span> <span class="n">available_time</span>  <span class="c1"># to get an approximate extrapolation</span>
        <span class="n">n_eval_tmp</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span>
        <span class="n">n_checks_tmp</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1">#time will be multiplied by actual n_checks</span>

        <span class="c1">#call hyper_optimization with parameters for &quot;one&quot; run and measure time</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">data_out</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Starting small test-run for time estimation.&quot;</span><span class="p">,</span>
                       <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># do-while loop</span>
        <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span>
        <span class="n">clf_tmp</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf_cp</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">start_timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="n">optimize_hyper_parameters</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">clf</span><span class="o">=</span><span class="n">clf_tmp</span><span class="p">,</span>
                                      <span class="n">n_eval</span><span class="o">=</span><span class="n">n_eval_tmp</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span> <span class="n">n_checks</span><span class="o">=</span><span class="n">n_checks_tmp</span><span class="p">,</span>
                                      <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">generator_type</span><span class="o">=</span><span class="n">generator_type</span><span class="p">,</span>
                                      <span class="n">take_target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">,</span> <span class="n">time_test</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_timer</span>
            <span class="k">if</span> <span class="n">elapsed_time</span> <span class="o">&gt;</span> <span class="n">min_elapsed_time</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">n_checks_tmp</span> <span class="o">&lt;</span> <span class="n">n_checks</span><span class="p">:</span>  <span class="c1"># for small datasets, increase n_checks for testing</span>
                <span class="n">n_checks_tmp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_checks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_elapsed_time</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_eval_tmp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_elapsed_time</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">)</span>  <span class="c1"># if time to small, increase n_rounds</span>

        <span class="n">elapsed_time</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_checks</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_checks_tmp</span><span class="p">)</span>  <span class="c1"># time for &quot;one round&quot;</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_timer_test</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">available_time</span> <span class="o">*</span> <span class="mf">0.98</span> <span class="o">-</span> <span class="n">test_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">))</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n_eval_tmp</span><span class="p">))</span>  <span class="c1"># we did just one</span>
        <span class="k">if</span> <span class="n">n_eval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_eval</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Time for one round:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;sec.&quot;</span><span class="p">,</span>
                        <span class="s2">&quot; Number of evaluations:&quot;</span><span class="p">,</span> <span class="n">n_eval</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="n">max_eval</span>

    <span class="n">n_eval</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="n">max_eval</span><span class="p">)</span>

    <span class="c1"># We do not need to create more data than we well test on</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">grid_param</span> <span class="o">!=</span> <span class="p">{},</span> <span class="s2">&quot;No values for optimization found&quot;</span>

    <span class="c1"># initialize data</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                      <span class="n">target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">)</span>

    <span class="c1"># initialize classifier</span>
    <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf_dict</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
    <span class="n">clf_name</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">parallel_profile</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span>

    <span class="c1"># rederict print output (for the hyperparameter-optimizer from rep)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s2">&quot;Starting hyper-optimization. This might take a while, no &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;output will be displayed during the process&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">IO_to_string</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;regression&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">RegressionParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;subgrid&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">SubgridParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">RandomParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; not a valid, implemented generator&quot;</span><span class="p">)</span>
    <span class="n">scorer</span> <span class="o">=</span> <span class="n">FoldingScorer</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span> <span class="n">fold_checks</span><span class="o">=</span><span class="n">n_checks</span><span class="p">)</span>
    <span class="n">grid_finder</span> <span class="o">=</span> <span class="n">GridOptimalSearchCV</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">scorer</span><span class="p">,</span> <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">)</span>

    <span class="c1"># Search for hyperparameters</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;starting &quot;</span> <span class="o">+</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyper optimization&quot;</span><span class="p">)</span>
    <span class="n">grid_finder</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyper optimization finished&quot;</span><span class="p">)</span>
    <span class="n">grid_finder</span><span class="o">.</span><span class="n">params_generator</span><span class="o">.</span><span class="n">print_results</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">IO_to_sys</span><span class="p">(</span><span class="n">subtitle</span><span class="o">=</span><span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyperparameter/feature optimization&quot;</span><span class="p">,</span>
                      <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">IO_to_sys</span><span class="p">(</span><span class="n">importance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="classify"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.classify">[docs]</a><span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="n">original_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
             <span class="n">clf</span><span class="o">=</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">plot_importance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">extended_report</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">curve_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conv_ori_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">conv_tar_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conv_vali_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">get_predictions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Training and testing a classifier or distinguish a dataset</span>

<span class="sd">    Classify is a multi-purpose function which does most of the things around</span>
<span class="sd">    machine-learning. It can be used for:</span>

<span class="sd">    - Training a clf.</span>
<span class="sd">        A quite simple task. You give some data, specify a clf and set</span>
<span class="sd">        validation to False (not mandatory actually, but pay attention if</span>
<span class="sd">        validation is set to an integer)</span>
<span class="sd">    - Predict data.</span>
<span class="sd">        Use either a pre-trained (see above) classifier or specify one with a</span>
<span class="sd">        string and give in some data to the validation and no to the</span>
<span class="sd">        original_data or target_data. Set get_predictions to True and you&#39;re</span>
<span class="sd">        done.</span>
<span class="sd">    - Get a ROC curve of two datasets.</span>
<span class="sd">        Specify the two input data (original_data and target_data) and use</span>
<span class="sd">        cross-validation by setting validation to the number of folds</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data for the training</span>
<span class="sd">    target_data : HEPDataStorage or None</span>
<span class="sd">        The target data for the training. If None, only the original_data will</span>
<span class="sd">        be used for the training.</span>
<span class="sd">    features : list(str, str, str...)</span>
<span class="sd">        List with features/columns to use in training.</span>
<span class="sd">    validation : int &gt;= 1 or HEPDataStorage</span>
<span class="sd">        You can either do cross-validation or give a testsample for the data.</span>

<span class="sd">        * Cross-validation:</span>
<span class="sd">            Enter an integer, which is the number of folds</span>
<span class="sd">        * Validation-dataset:</span>
<span class="sd">            Enter a *HEPDataStorage* which contains data to be tested on.</span>
<span class="sd">            The target-label will be taken from it, so ensure that they are</span>
<span class="sd">            not None! To use two datasets, you can also use a list of</span>
<span class="sd">            **maximum** two datastorages.</span>
<span class="sd">    clf : str {&#39;xgb&#39;, &#39;rdf&#39;} or REP-classifier</span>
<span class="sd">        The classifier to be used for the training and predicting. If you don&#39;t</span>
<span class="sd">        pass a classifier (with *fit*, *predict* and *predict_proba* at least),</span>
<span class="sd">        an XGBoost classifier will be used.</span>
<span class="sd">    plot_importance : int {0, 1, 2, 3, 4, 5}</span>
<span class="sd">        The higher the importance, the more likely the plots will be showed.</span>
<span class="sd">        All plots should be saved anyway.</span>
<span class="sd">    extended_report : boolean</span>
<span class="sd">        If True, make extended reports on the classifier as well as on the data,</span>
<span class="sd">        including feature correlation, feature importance etc.</span>
<span class="sd">    plot_title : str</span>
<span class="sd">        A part of the title of the plots.</span>
<span class="sd">    curve_name : str</span>
<span class="sd">        A labeling for the plotted data.</span>
<span class="sd">    target_from_data : boolean</span>
<span class="sd">        | If true, the target-values (labels; 0 or 1) for the original and the</span>
<span class="sd">          target data will be taken from the</span>
<span class="sd">          data instead of assigned accordingly (original:1, target:0).</span>
<span class="sd">        | If no target_data is provided, the targets/labels will be taken</span>
<span class="sd">          from the original_data anyway.</span>
<span class="sd">    get_predictions : boolean</span>
<span class="sd">        If True, return a dictionary containing the prediction probabilities, the</span>
<span class="sd">        true y-values and maybe, in the futur, even more.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : clf</span>
<span class="sd">        Return the trained classifier.</span>
<span class="sd">    .. note::</span>
<span class="sd">        If validation was choosen to be KFold, the returned classifier well be</span>
<span class="sd">        instance of :py:class:`~rep.metaml.folding.FoldingClassifier()`!</span>
<span class="sd">    out : float (only if validation is not None)</span>
<span class="sd">        Return the score (recall or roc auc) of the validation. If only one</span>
<span class="sd">        class (sort of labels, mostly if data for validation is provided) is</span>
<span class="sd">        given, the recall will be computed. Otherwise the ROC-AUC (like for</span>
<span class="sd">        cross-validation)</span>
<span class="sd">    out : dict  (only if *get_predictions* is True)</span>
<span class="sd">        Return a dict containing the predictions, probability and more.</span>

<span class="sd">        - &#39;y_pred&#39; : predictions of the classifier</span>
<span class="sd">        - &#39;y_proba&#39; : prediciton probabilities</span>
<span class="sd">        - &#39;y_true&#39; : the true labels of the data (if available)</span>
<span class="sd">        - &#39;weights&#39; : the weights of the corresponding predicitons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting classify with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf</span><span class="p">))</span>
    <span class="c1"># initialize variables and data</span>
    <span class="n">save_fig_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_SAVE_FIG</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">save_fig_cfg</span><span class="p">)</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">make_plot</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># used if no validation</span>

    <span class="n">plot_title</span> <span class="o">=</span> <span class="s2">&quot;classify&quot;</span> <span class="k">if</span> <span class="n">plot_title</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">plot_title</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">original_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">target_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">original_data</span>  <span class="c1"># switch places</span>
    <span class="k">if</span> <span class="n">original_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                          <span class="n">target_from_data</span><span class="o">=</span><span class="n">target_from_data</span><span class="p">,</span>
                                          <span class="n">conv_ori_weights</span><span class="o">=</span><span class="n">conv_ori_weights</span><span class="p">,</span>
                                          <span class="n">conv_tar_weights</span><span class="o">=</span><span class="n">conv_tar_weights</span><span class="p">,</span>
                                          <span class="n">weights_ratio</span><span class="o">=</span><span class="n">weights_ratio</span><span class="p">)</span>
        <span class="n">data_name</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">target_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_name</span> <span class="o">+=</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">target_data</span><span class="o">.</span><span class="n">name</span>

    <span class="n">clf_name</span> <span class="o">=</span> <span class="s1">&#39;classifier&#39;</span>
    <span class="k">if</span> <span class="n">clf</span> <span class="o">==</span> <span class="s1">&#39;xgb&#39;</span><span class="p">:</span>
        <span class="n">clf_name</span> <span class="o">=</span> <span class="s1">&#39;XGBoost classifier&#39;</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">XGBoostClassifier</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_XGB</span><span class="p">,</span> <span class="n">nthreads</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">free_cpus</span><span class="p">()))</span>
        <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">clf</span> <span class="o">==</span> <span class="s1">&#39;rdf&#39;</span><span class="p">:</span>
        <span class="n">clf_name</span> <span class="o">=</span> <span class="s2">&quot;RandomForest classifier&quot;</span>
        <span class="n">cfg_clf</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_RDF</span><span class="p">,</span>
        <span class="n">cfg_clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">free_cpus</span><span class="p">(),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">432</span><span class="p">)</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">cfg_clf</span><span class="p">))</span>
        <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">clf</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
        <span class="n">clf_name</span> <span class="o">=</span> <span class="s2">&quot;Theanets Neural Network&quot;</span>
        <span class="n">cfg_clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_NN</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">globals_</span><span class="o">.</span><span class="n">randint</span><span class="o">+</span><span class="mi">1817</span><span class="p">)</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">TheanetsClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">cfg_clf</span><span class="p">)</span>
        <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">):</span>
        <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not a valid classifier or string for a clf&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">and</span> <span class="n">validation</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_parallel</span><span class="p">:</span>
            <span class="n">parallel_profile</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parallel_profile</span> <span class="o">=</span> <span class="s1">&#39;threads-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">globals_</span><span class="o">.</span><span class="n">free_cpus</span><span class="p">(),</span> <span class="n">validation</span><span class="p">))</span>

        <span class="n">clf</span> <span class="o">=</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">validation</span><span class="p">),</span> <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">,</span>
                                <span class="n">stratified</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">use_stratified_folding</span><span class="p">)</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">LabeledDataStorage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># folding-&gt; same data for train and test</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">):</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">validation</span><span class="o">.</span><span class="n">get_LabeledDataStorage</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">features</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">validation</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">make_plot</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">clf_score</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">data_val</span><span class="p">,</span> <span class="n">target_val</span><span class="p">,</span> <span class="n">weights_val</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">validation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">validation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                       <span class="n">conv_ori_weights</span><span class="o">=</span><span class="n">conv_vali_weights</span><span class="p">,</span>
                                                       <span class="n">conv_tar_weights</span><span class="o">=</span><span class="n">conv_vali_weights</span><span class="p">)</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">LabeledDataStorage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data_val</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target_val</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">weights_val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Validation method &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">validation</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; not a valid choice&quot;</span><span class="p">)</span>

    <span class="c1"># train the classifier</span>
    <span class="k">if</span> <span class="n">original_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>  <span class="c1"># if error &quot;1 not in list&quot; or similar occurs: no valid targets (None?)</span>

    <span class="c1"># test the classifier</span>
    <span class="k">if</span> <span class="n">validation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">ClassificationReport</span><span class="p">({</span><span class="n">clf_name</span><span class="p">:</span> <span class="n">clf</span><span class="p">},</span> <span class="n">lds_test</span><span class="p">)</span>
        <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">n_classes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">clf_score</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;ROC AUC of &quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">],</span>
                           <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Report of classify&quot;</span><span class="p">,</span>
                           <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot;, AUC = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">)</span>
            <span class="n">binary_test</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">n_classes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># score returns accuracy; if only one label present, it is the same as recall</span>
            <span class="n">y_true</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
            <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">get_predictions</span><span class="p">:</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_proba&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_proba</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_pred&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_true&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_true</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">allow_nones</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
            <span class="n">clf_score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">w_test</span><span class="p">)</span>
            <span class="n">clf_score2</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">y_pred</span><span class="p">)</span><span class="c1">#, sample_weight=w_test)</span>
            <span class="n">class_rep</span> <span class="o">=</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w_test</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">class_rep</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Classification report &quot;</span> <span class="o">+</span> <span class="n">clf_name</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;accuracy NO WEIGHTS! (just for curiosity):&quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span>
                            <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">curve_name</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">clf_score2</span><span class="p">],</span>
                            <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Report of classify&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;recall of&quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">curve_name</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">],</span>
                           <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">binary_test</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot;, recall = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multi-label classification not supported&quot;</span><span class="p">)</span>

    <span class="c1">#plots</span>

    <span class="k">if</span> <span class="n">make_plot</span><span class="p">:</span>  <span class="c1"># if no validation is given, don&#39;t make plots</span>
        <span class="k">if</span> <span class="n">curve_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">curve_name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">plot_name</span>
        <span class="n">report</span><span class="o">.</span><span class="n">prediction</span><span class="p">[</span><span class="n">plot_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">prediction</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">clf_name</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">estimators</span><span class="p">[</span><span class="n">plot_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">estimators</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">clf_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binary_test</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">plot_title</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">),</span>
                         <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">roc</span><span class="p">(</span><span class="n">physics_notion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">plot_title</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ROC curve of&quot;</span> <span class="o">+</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; on data:&quot;</span> <span class="o">+</span>
                                                   <span class="n">data_name</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ROC AUC = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>  <span class="c1"># the fifty-fifty line</span>

            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;Learning curve&quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">),</span>
                         <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">learning_curve</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Learning curve of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># TODO: implement learning curve with tpr metric</span>
<span class="c1">#            out.save_fig(plt.figure(&quot;Learning curve&quot; + plot_name),</span>
<span class="c1">#                         importance=plot_importance, **save_fig_cfg)</span>
<span class="c1">#            report.learning_curve(metrics., steps=1).plot(title=&quot;Learning curve of &quot; + plot_name)</span>
        <span class="k">if</span> <span class="n">extended_report</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Feature importance shuffling of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
                <span class="n">report</span><span class="o">.</span><span class="n">feature_importance_shuffling</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature importance shuffling of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Feature correlation matrix of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
                <span class="n">report</span><span class="o">.</span><span class="n">features_correlation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Predictiond pdf of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">prediction_pdf</span><span class="p">(</span><span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">clf_score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span>
    <span class="k">elif</span> <span class="n">get_predictions</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">,</span> <span class="n">predictions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span><span class="p">,</span> <span class="n">clf_score</span></div>

    <span class="c1">#return clf, clf_score if clf_score is not None else clf</span>


<div class="viewcode-block" id="reweight_train"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_train">[docs]</a><span class="k">def</span> <span class="nf">reweight_train</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="p">,</span> <span class="n">reweight_data_real</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">reweighter</span><span class="o">=</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">reweight_saveas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">weights_mc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_real</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a trained reweighter from a (mc/real) distribution comparison.</span>

<span class="sd">    | Reweighting a distribution is a &quot;making them the same&quot; by changing the \</span>
<span class="sd">    weights of the bins (instead of 1) for each event. Mostly, and therefore \</span>
<span class="sd">    the naming, you want to change the mc-distribution towards the real one.</span>
<span class="sd">    | There are two possibilities</span>

<span class="sd">    * normal bins reweighting:</span>
<span class="sd">       divides the bins from one distribution by the bins of the other</span>
<span class="sd">       distribution. Easy and fast, but unstable and inaccurat for higher</span>
<span class="sd">       dimensions.</span>
<span class="sd">    * Gradient Boosted reweighting:</span>
<span class="sd">       uses several decision trees to reweight the bins. Slower, but more</span>
<span class="sd">       accurat. Very useful in higher dimensions.</span>
<span class="sd">       But be aware, that you can easily screw up things by overfitting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reweight_data_mc : :class:`HEPDataStorage`</span>
<span class="sd">        The Monte-Carlo data, which has to be &quot;fitted&quot; to the real data.</span>
<span class="sd">    reweight_data_real : :class:`HEPDataStorage`</span>
<span class="sd">        Same as *reweight_data_mc* but for the real data.</span>
<span class="sd">    columns : list of strings</span>
<span class="sd">        The columns/features/branches you want to use for the reweighting.</span>
<span class="sd">    reweighter : {&#39;gb&#39;, &#39;bins&#39;}</span>
<span class="sd">        Specify which reweighter to be used</span>
<span class="sd">    reweight_saveas : string</span>
<span class="sd">        To save a trained reweighter in addition to return it. The value</span>
<span class="sd">        is the file(path +)name. The full name will be</span>
<span class="sd">         PICKLE_PATH + reweight_saveas + .pickle</span>
<span class="sd">        (.pickle is only added if not yet contained in &quot;reweight_saveas&quot;)</span>
<span class="sd">    meta_cfg : dict</span>
<span class="sd">        Contains the parameters for the bins/gb-reweighter. See also</span>
<span class="sd">        :func:`~hep_ml.reweight.BinsReweighter` and</span>
<span class="sd">        :func:`~hep_ml.reweight.GBReweighter`.</span>
<span class="sd">    weights_mc : numpy.array [n_samples]</span>
<span class="sd">        Explicit weights for the Monte-Carlo data. Only specify if you don&#39;t</span>
<span class="sd">        want to use the weights in the *HEPDataStorage*.</span>
<span class="sd">    weights_real : numpy.array [n_samples]</span>
<span class="sd">        Explicit weights for the real data. Only specify if you don&#39;t</span>
<span class="sd">        want to use the weights in the *HEPDataStorage*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : object of type reweighter</span>
<span class="sd">        Reweighter is trained to the data. Can, for example,</span>
<span class="sd">        be used with :func:`~hep_ml.reweight.GBReweighter.predict_weights`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__REWEIGHT_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gb&#39;</span><span class="p">:</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;bins&#39;</span><span class="p">:</span> <span class="s1">&#39;Bins&#39;</span><span class="p">,</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span> <span class="s1">&#39;Bins&#39;</span><span class="p">}</span>

    <span class="c1"># check for valid user input</span>
    <span class="k">if</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">is_pickle</span><span class="p">(</span><span class="n">reweighter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">adv_return</span><span class="p">(</span><span class="n">reweighter</span><span class="p">,</span> <span class="n">save_name</span><span class="o">=</span><span class="n">reweight_saveas</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">reweighter</span> <span class="o">=</span> <span class="n">__REWEIGHT_MODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reweighter</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reweighter invalid: &quot;</span> <span class="o">+</span> <span class="n">reweighter</span><span class="p">)</span>
    <span class="n">reweighter</span> <span class="o">+=</span> <span class="s1">&#39;Reweighter&#39;</span>

    <span class="c1"># logging and writing output</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Reweighter:&quot;</span><span class="p">,</span> <span class="n">reweighter</span><span class="p">,</span> <span class="s2">&quot;with config:&quot;</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="p">]</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="c1"># TODO: columns = reweight_data_mc.columns if columns is None else columns</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Data used:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot; and &quot;</span><span class="p">,</span>
                   <span class="n">reweight_data_real</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">columns used for the reweighter training:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">],</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Training the reweighter&quot;</span><span class="p">,</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># use the intesection of both colomns</span>
        <span class="n">common_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">common_cols</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">reweight_data_real</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="o">!=</span> <span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">columns</span> <span class="o">!=</span> <span class="n">reweight_data_real</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No columns specified for reweighting, took intersection&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot; of both dataset, as it&#39;s columns are not equal.&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Therefore some columns were not used!&quot;</span><span class="p">)</span>
            <span class="n">meta_config</span><span class="o">.</span><span class="n">warning_occured</span><span class="p">()</span>

    <span class="c1"># train the reweighter</span>
<span class="c1"># TODO: remove next line, accidentialy inserted?</span>
    <span class="c1"># hep_ml.reweight.BinsReweighter()</span>
    <span class="n">reweighter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hep_ml</span><span class="o">.</span><span class="n">reweight</span><span class="p">,</span> <span class="n">reweighter</span><span class="p">)(</span><span class="o">**</span><span class="n">meta_cfg</span><span class="p">)</span>
    <span class="n">reweighter</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">original</span><span class="o">=</span><span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">pandasDF</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">),</span>
                   <span class="n">target</span><span class="o">=</span><span class="n">reweight_data_real</span><span class="o">.</span><span class="n">pandasDF</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">),</span>
                   <span class="n">original_weight</span><span class="o">=</span><span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(),</span>
                   <span class="n">target_weight</span><span class="o">=</span><span class="n">reweight_data_real</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">adv_return</span><span class="p">(</span><span class="n">reweighter</span><span class="p">,</span> <span class="n">save_name</span><span class="o">=</span><span class="n">reweight_saveas</span><span class="p">)</span></div>


<div class="viewcode-block" id="reweight_weights"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_weights">[docs]</a><span class="k">def</span> <span class="nf">reweight_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="p">,</span> <span class="n">reweighter_trained</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add (or only return) new weights to the data by applying a given</span>
<span class="sd">    reweighter on the reweight_data.</span>

<span class="sd">    Can be seen as a wrapper for the</span>
<span class="sd">    :py:func:`~hep_ml.reweight.GBReweighter.predict_weights` method.</span>
<span class="sd">    Additional functionality:</span>
<span class="sd">     * Takes a trained reweighter as argument, but can also unpickle one</span>
<span class="sd">       from a file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reweight_data : :class:`HEPDataStorage`</span>
<span class="sd">        The data for which the reweights are to be predicted.</span>
<span class="sd">    reweighter_trained : (pickled) reweighter (*from hep_ml*)</span>
<span class="sd">        The trained reweighter, which predicts the new weights.</span>
<span class="sd">    normalize : boolean</span>
<span class="sd">        If True, the weights will be normalized to one.</span>
<span class="sd">    add_weights_to_data : boolean</span>
<span class="sd">        If set to False, the weights will only be returned and not updated in</span>
<span class="sd">        the data (*HEPDataStorage*).</span>

<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    out : numpy.array</span>
<span class="sd">        Return a numpy.array of shape [n_samples] containing the new</span>
<span class="sd">        weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reweighter_trained</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">try_unpickle</span><span class="p">(</span><span class="n">reweighter_trained</span><span class="p">)</span>
    <span class="n">new_weights</span> <span class="o">=</span> <span class="n">reweighter_trained</span><span class="o">.</span><span class="n">predict_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="o">.</span><span class="n">pandasDF</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">),</span>
                                        <span class="n">original_weight</span><span class="o">=</span><span class="n">reweight_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>

    <span class="c1"># write to output</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Using the reweighter:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">reweighter_trained</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> to reweight &quot;</span><span class="p">,</span>
                    <span class="n">reweight_data</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># old... remove? TODO</span>
            <span class="n">new_weights</span> <span class="o">*=</span> <span class="n">new_weights</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">new_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">add_weights_to_data</span><span class="p">:</span>
        <span class="n">reweight_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_weights</span></div>

<div class="viewcode-block" id="reweight_Kfold"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_Kfold">[docs]</a><span class="k">def</span> <span class="nf">reweight_Kfold</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="p">,</span> <span class="n">reweight_data_real</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                   <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reweighter</span><span class="o">=</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score_clf</span><span class="o">=</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span>
                   <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mcreweighted_as_real_score</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reweight data by &quot;itself&quot; for *scoring* and hyper-parameters via</span>
<span class="sd">    Kfolding to avoid bias.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       Do NOT use for the real reweighting process! (except if you really want</span>
<span class="sd">       to reweight the data &quot;by itself&quot;)</span>


<span class="sd">    If you want to figure out the hyper-parameters for a reweighting process</span>
<span class="sd">    or just want to find out how good the reweighter works, you may want to</span>
<span class="sd">    apply this to the data itself. This means:</span>

<span class="sd">    - train a reweighter on mc/real</span>
<span class="sd">    - apply it to get new weights for mc</span>
<span class="sd">    - compare the mc/real distribution</span>

<span class="sd">    The problem arises with biasing your reweighter. As in classification</span>
<span class="sd">    tasks, where you split your data into train/test sets for Kfolds, you</span>
<span class="sd">    want to do the same here. Therefore:</span>

<span class="sd">    - split the mc data into (n_folds-1)/n_folds (training)</span>
<span class="sd">    - train the reweighter on the training mc/complete real (if</span>
<span class="sd">      mcreweighted_as_real_score is True, the real data will be folded too</span>
<span class="sd">      for unbiasing the score)</span>
<span class="sd">    - reweight the leftout mc test-fold</span>
<span class="sd">    - do this n_folds times</span>
<span class="sd">    - getting unbiased weights</span>

<span class="sd">    The parameters are more or less the same as for the</span>
<span class="sd">    :py:func:`~raredecay.analysis.ml_analysis.reweight_train` and</span>
<span class="sd">    :py:func:`~raredecay.analysis.ml_analysis.reweight_weights`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reweight_data_mc : :class:`HEPDataStorage`</span>
<span class="sd">        The Monte-Carlo data, which has to be &quot;fitted&quot; to the real data.</span>
<span class="sd">    reweight_data_real : :class:`HEPDataStorage`</span>
<span class="sd">        Same as *reweight_data_mc* but for the real data.</span>
<span class="sd">    n_folds : int &gt;= 1</span>
<span class="sd">        The number of folds to split the data. Usually, the more folds the</span>
<span class="sd">        &quot;better&quot; reweighting.</span>

<span class="sd">        If n_folds = 1, the data will be reweighted directly and the benefit</span>
<span class="sd">        of Kfolds and the unbiasing *disappears*</span>


<span class="sd">    columns : list of strings</span>
<span class="sd">        The columns/features/branches you want to use for the reweighting.</span>
<span class="sd">    reweighter : {&#39;gb&#39;, &#39;bins&#39;}</span>
<span class="sd">        Specify which reweighter to be used</span>
<span class="sd">    reweight_saveas : string</span>
<span class="sd">        To save a trained reweighter in addition to return it. The value</span>
<span class="sd">        is the file(path +)name. The full name will be</span>
<span class="sd">         PICKLE_PATH + reweight_saveas + .pickle</span>
<span class="sd">        (.pickle is only added if not yet contained in &quot;reweight_saveas&quot;)</span>
<span class="sd">    meta_cfg : dict</span>
<span class="sd">        Contains the parameters for the bins/gb-reweighter. See also</span>
<span class="sd">        :func:`~hep_ml.reweight.BinsReweighter` and</span>
<span class="sd">        :func:`~hep_ml.reweight.GBReweighter`.</span>
<span class="sd">    add_weights_to_data : boolean</span>
<span class="sd">        If True, the new weights will be added (in place) to the mc data and</span>
<span class="sd">        returned. Otherwise, the weights will only be returned.</span>
<span class="sd">    mcreweighted_as_real_score : boolean or str</span>
<span class="sd">        If a string, it has to be an implemented classifier in *classify*.</span>
<span class="sd">        If true, the default (&#39;xgb&#39; most probably) will be used.</span>

<span class="sd">        If not False, calculate and print the score. This scoring is based on a</span>
<span class="sd">        clf, which was trained on the not reweighted mc and real data and</span>
<span class="sd">        tested on the reweighted mc, and then predicts how many it &quot;thinks&quot;</span>
<span class="sd">        are real datapoints.</span>

<span class="sd">        Intuitively, a classifiers learns to distinguish between mc and real</span>
<span class="sd">        and then classifies mc reweighted data labeled as real; he says, how</span>
<span class="sd">        &quot;real&quot; the reweighted data looks like. So a higher score is better.</span>
<span class="sd">        Drawback of this method is, it is completely blind to over-fitting</span>
<span class="sd">        of the reweighter. To get a relation, the classifier also predicts</span>
<span class="sd">        the mc (which should be an under limit) as well as the real data</span>
<span class="sd">        (which should be an upper limit).</span>

<span class="sd">        Even dough this scoring sais not a lot about how well the reweighting</span>
<span class="sd">        worked, we can say, that if the score is higher than the real one,</span>
<span class="sd">        it has somehow over-fitted (if a classifier cannot classify, say,</span>
<span class="sd">        more than 70% of the real data as real, it should not be able to</span>
<span class="sd">        classify more than 70% of the reweighted mc as real. Reweighted mc</span>
<span class="sd">        should not &quot;look more real&quot; than real data)</span>
<span class="sd">    out : numpy array</span>
<span class="sd">        Return the new weights</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Doing reweighting_Kfold with &quot;</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="s2">&quot; folds&quot;</span><span class="p">],</span>
                   <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Reweighting Kfold&quot;</span><span class="p">,</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># create variables</span>
    <span class="k">assert</span> <span class="n">n_folds</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_folds</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;n_folds has to be &gt;= 1, its currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">),</span> <span class="s2">&quot;wrong data type. Has to be HEPDataStorage, is currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reweight_data_real</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">),</span> <span class="s2">&quot;wrong data type. Has to be HEPDataStorage, is currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reweight_data_real</span><span class="p">))</span>



    <span class="n">new_weights_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_weights_index</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">score_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">score_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>


    <span class="c1"># split data to folds and loop over them</span>
    <span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">make_folds</span><span class="p">(</span><span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">)</span>
    <span class="n">reweight_data_real</span><span class="o">.</span><span class="n">make_folds</span><span class="p">(</span><span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data created, starting folding&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>

        <span class="c1"># create train/test data</span>
        <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">train_real</span><span class="p">,</span> <span class="n">test_real</span> <span class="o">=</span> <span class="n">reweight_data_real</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_real</span> <span class="o">=</span> <span class="n">test_real</span> <span class="o">=</span> <span class="n">reweight_data_real</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">train_mc</span><span class="p">,</span> <span class="n">test_mc</span> <span class="o">=</span> <span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_mc</span> <span class="o">=</span> <span class="n">test_mc</span> <span class="o">=</span> <span class="n">reweight_data_mc</span>

        <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
            <span class="n">old_mc_weights</span> <span class="o">=</span> <span class="n">test_mc</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>

        <span class="c1"># plot the first fold as example (the first one surely exists)</span>
        <span class="n">plot_importance1</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">fold</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">train_real</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Reweighter trainer, example, fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span>
                            <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance1</span><span class="p">)</span>
            <span class="n">train_mc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Reweighter trainer, example, fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span>
                          <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance1</span><span class="p">)</span>

        <span class="c1"># train reweighter on training data</span>
        <span class="n">reweighter_trained</span> <span class="o">=</span> <span class="n">reweight_train</span><span class="p">(</span><span class="n">reweight_data_mc</span><span class="o">=</span><span class="n">train_mc</span><span class="p">,</span>
                                            <span class="n">reweight_data_real</span><span class="o">=</span><span class="n">train_real</span><span class="p">,</span>
                                            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">reweighter</span><span class="o">=</span><span class="n">reweighter</span><span class="p">,</span>
                                            <span class="n">meta_cfg</span><span class="o">=</span><span class="n">meta_cfg</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reweighting fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;finished&quot;</span><span class="p">)</span>

        <span class="n">new_weights</span> <span class="o">=</span> <span class="n">reweight_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                                       <span class="n">reweighter_trained</span><span class="o">=</span><span class="n">reweighter_trained</span><span class="p">,</span>
                                       <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># fold only, not full data</span>
        <span class="c1"># plot one for example of the new weights</span>
        <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="s2">&quot;new weights of fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">new_weights</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
            <span class="c1"># treat reweighted mc data as if it were real data target(1)</span>
            <span class="n">test_mc</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># train clf on real and mc and see where it classifies the reweighted mc</span>
            <span class="n">clf</span><span class="p">,</span> <span class="n">scores</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">train_mc</span><span class="p">,</span> <span class="n">train_real</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span>
                                         <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;mc reweighted as real&quot;</span><span class="p">,</span>
                                         <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; reweighted validation&quot;</span><span class="p">,</span>
                                         <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clf</span><span class="o">=</span><span class="n">score_clf</span><span class="p">)</span>

            <span class="c1"># Get the max and min for &quot;calibration&quot; of the possible score for the reweighted data by</span>
            <span class="c1"># passing in mc and label it as real (worst/min score) and real labeled as real (best/max)</span>
            <span class="n">test_mc</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">old_mc_weights</span><span class="p">)</span>  <span class="c1"># TODO: check, was new implemented. Before was 1</span>
            <span class="n">tmp_</span><span class="p">,</span> <span class="n">score_min</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span>
                                             <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;mc as real&quot;</span><span class="p">)</span>
            <span class="n">test_real</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tmp_</span><span class="p">,</span> <span class="n">score_max</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_real</span><span class="p">,</span>
                                             <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;real as real&quot;</span><span class="p">)</span>


        <span class="c1"># collect all the new weights to get a really cross-validated reweighted dataset</span>
        <span class="n">new_weights_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
        <span class="n">new_weights_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_mc</span><span class="o">.</span><span class="n">get_index</span><span class="p">())</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;finished&quot;</span><span class="p">)</span>
        <span class="c1"># end of for-loop</span>

    <span class="c1">#concatenate weights and index</span>
    <span class="k">if</span> <span class="n">n_folds</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">new_weights_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">)</span>
        <span class="n">new_weights_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_weights_index</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_weights_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">)</span>
        <span class="n">new_weights_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_weights_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">add_weights_to_data</span><span class="p">:</span>
        <span class="n">reweight_data_mc</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_weights_index</span><span class="p">)</span>

    <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;New weights of total mc&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;New weights of reweighting with Kfold&quot;</span><span class="p">)</span>

    <span class="c1"># create score</span>
    <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Kfold reweight report&quot;</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Precision scores of classification on reweighted mc&quot;</span><span class="p">)</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;Reweighted: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="s1">&#39;score_reweighted&#39;</span><span class="p">),</span>
                      <span class="p">(</span><span class="s2">&quot;mc as real (min): &quot;</span><span class="p">,</span> <span class="n">score_min</span><span class="p">,</span> <span class="s1">&#39;score_min&#39;</span><span class="p">),</span>
                      <span class="p">(</span><span class="s2">&quot;real as real (max): &quot;</span><span class="p">,</span> <span class="n">score_max</span><span class="p">,</span> <span class="s1">&#39;score_max&#39;</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">score_list</span><span class="p">:</span>
            <span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Classify the target, average score &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">std</span><span class="p">)],</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>

    <span class="n">new_weights_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_weights_index</span><span class="p">)</span>

    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_weights_all</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;main&quot;</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s1">&#39;test&#39;</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonas Eschle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0a',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>