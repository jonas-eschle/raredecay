

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>raredecay.analysis.ml_analysis &mdash; raredecay 1.2.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="raredecay 1.2.1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> raredecay
          

          
          </a>

          
            
            
              <div class="version">
                1.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../raredecay.html">Raredecay Analysis Package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">raredecay</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>raredecay.analysis.ml_analysis</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for raredecay.analysis.ml_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sat Mar 26 11:29:01 2016</span>

<span class="sd">@author: Jonas Eschle &quot;Mayou36&quot;</span>

<span class="sd">The Machine Learning Analysis module consists of machine-learning functions</span>
<span class="sd">which are mostly wrappers around already existing algorithms.</span>

<span class="sd">Several &quot;new types&quot; of formats are introduced by using the available formats</span>
<span class="sd">from all the libraries (scikit-learn, pandas, numpy etc) and brings together</span>
<span class="sd">what belongs together. It takes away all the unnecessary work done so many</span>
<span class="sd">times for the simple tasks.</span>

<span class="sd">The functions serve as basic tools, which do already a lot of the work.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>


<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># hep_ml imports</span>
<span class="kn">import</span> <span class="nn">hep_ml.reweight</span>

<span class="c1"># scikit-learn imports</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="k">import</span> <span class="n">BaseEstimator</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">GradientBoostingClassifier</span><span class="p">,</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">AdaBoostClassifier</span>  <span class="c1"># , VotingClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="k">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">KNeighborsClassifier</span>

<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">classification_report</span>  <span class="c1"># recall_score,</span>

<span class="c1"># import Reproducible Experimental Platform</span>
<span class="kn">from</span> <span class="nn">rep.data</span> <span class="k">import</span> <span class="n">LabeledDataStorage</span>

<span class="kn">from</span> <span class="nn">rep.estimators</span> <span class="k">import</span> <span class="n">SklearnClassifier</span><span class="p">,</span> <span class="n">XGBoostClassifier</span><span class="p">,</span> <span class="n">TMVAClassifier</span>
<span class="kn">from</span> <span class="nn">rep.estimators.theanets</span> <span class="k">import</span> <span class="n">TheanetsClassifier</span>
<span class="kn">from</span> <span class="nn">rep.estimators.interface</span> <span class="k">import</span> <span class="n">Classifier</span>

<span class="kn">from</span> <span class="nn">rep.metaml.folding</span> <span class="k">import</span> <span class="n">FoldingClassifier</span>
<span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="k">import</span> <span class="n">GridOptimalSearchCV</span><span class="p">,</span> <span class="n">FoldingScorer</span><span class="p">,</span> <span class="n">RandomParameterOptimizer</span>
<span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="k">import</span> <span class="n">SubgridParameterOptimizer</span>
<span class="kn">from</span> <span class="nn">rep.metaml.gridsearch</span> <span class="k">import</span> <span class="n">RegressionParameterOptimizer</span>  <span class="c1"># , AnnealingParameterOptimizer</span>

<span class="kn">from</span> <span class="nn">rep.report</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="kn">from</span> <span class="nn">rep.report.classification</span> <span class="k">import</span> <span class="n">ClassificationReport</span>

<span class="c1"># raredecay imports</span>
<span class="kn">from</span> <span class="nn">raredecay.tools</span> <span class="k">import</span> <span class="n">dev_tool</span><span class="p">,</span> <span class="n">data_tools</span><span class="p">,</span> <span class="n">data_storage</span>
<span class="kn">from</span> <span class="nn">raredecay.globals_</span> <span class="k">import</span> <span class="n">out</span>
<span class="c1"># from raredecay import globals_</span>

<span class="c1"># import configuration</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">from</span> <span class="nn">raredecay</span> <span class="k">import</span> <span class="n">meta_config</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">run_config</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">make_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">logger_cfg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights_original</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_target</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the concatenated data, weights and labels for classifier training.</span>

<span class="sd">     Differs to only *make_dataset* from the HEPDataStorage by providing the</span>
<span class="sd">     possibility of using other weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make temporary weights if specific weights are given as parameters</span>
    <span class="n">temp_ori_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">temp_tar_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">weights_original</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">temp_ori_weights</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weights_original</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">weights_target</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">temp_tar_weights</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
        <span class="n">target_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weights_target</span><span class="p">)</span>

    <span class="c1"># create the data, target and weights</span>
    <span class="n">data_out</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">(</span><span class="n">target_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                          <span class="n">targets_from_data</span><span class="o">=</span><span class="n">target_from_data</span><span class="p">,</span>
                                          <span class="n">weights_ratio</span><span class="o">=</span><span class="n">weights_ratio</span><span class="p">)</span>

    <span class="c1"># reassign weights if specific weights have been used</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">temp_ori_weights</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_ori_weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dev_tool</span><span class="o">.</span><span class="n">is_in_primitive</span><span class="p">(</span><span class="n">temp_tar_weights</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_tar_weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_out</span>


<div class="viewcode-block" id="make_clf"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.make_clf">[docs]</a><span class="k">def</span> <span class="nf">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dict_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a classifier-dict. Takes a str, config-dict or clf-dict or clf.</span>

<span class="sd">    This function is used to bring classifiers into the &quot;same&quot; format. It</span>
<span class="sd">    takes several kind of arguments, extracts the information, sorts it and</span>
<span class="sd">    creates an instance of a classifier if needed.</span>

<span class="sd">    Currently implemented classifiers are found below</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clf : dict or str or sklearn/REP-classifier</span>
<span class="sd">        There are several ways to pass the classifier to the function.</span>

<span class="sd">        - Pure classifier: You can pass a classifier to the method,</span>
<span class="sd">          either a scikit-learn or a REP classifier.</span>
<span class="sd">        - Classifier with name: you can name your classifier by either:</span>

<span class="sd">          - using a dict with {&#39;my_clf_1&#39;: clf}</span>
<span class="sd">          - using a dict with {&#39;name&#39;: &#39;my_clf_1&#39;, &#39;clf&#39;: clf}</span>
<span class="sd">            where clf referes to the classifier and &#39;my_clf_1&#39; can be any name.</span>
<span class="sd">        - Configuration for a clf: Instead of instantiating the clf outside,</span>
<span class="sd">          you can also pass a configuration-dictionary. This has to look like:</span>

<span class="sd">          - {&#39;*clf_type*&#39;: config-dict, &#39;name&#39;: &#39;my_clf_1&#39;} (name is optional)</span>
<span class="sd">            whereas &#39;clf_type&#39; has to be any of the implemented clf-types like</span>
<span class="sd">            &#39;xgb&#39;, &#39;rdf&#39;, &#39;ada&#39; etc.</span>
<span class="sd">        - Get a standard-clf: providing a *string* only refering to an implemented</span>
<span class="sd">          clf-type, you will get a classifier using the configuration in</span>
<span class="sd">          :py:mod:`~raredecay.meta_config`</span>

<span class="sd">    n_cpu : int or None</span>
<span class="sd">        The number of cpus to use for this classifier. If the classifier is not</span>
<span class="sd">        parallelizable, an according *parallel_profile* (also see in REP-docs)</span>
<span class="sd">        will be created; &#39;threads-n&#39; with n the number of cpus specified before.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This overwrites the global n-cpu settings for this specific classifier</span>
<span class="sd">    dict_only : boolean</span>
<span class="sd">        If True, only a dictionary will be returned containing the name, config,</span>
<span class="sd">        clf_type and parallel_profile, n_cpu, but no classifier instance will</span>
<span class="sd">        be created.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        A dictionary containing the name (&#39;name&#39;) of the classifier as well</span>
<span class="sd">        as the classifier itself (&#39;clf&#39;). If *dict_only* is True, no clf will</span>
<span class="sd">        be returned but a &#39;clf_type&#39; as well as a &#39;config&#39; key.</span>
<span class="sd">        Additionally, there are more values that can be contained: if a</span>
<span class="sd">        configuration and not an already instantiated clf is given:</span>

<span class="sd">        - **parallel_profile**: the parallel-profile (for different REP-functions)</span>
<span class="sd">          which is set according to the n_cpus entered as well as the n_cpus</span>
<span class="sd">          used. If n cpus should be used, the classifier takes, the profile</span>
<span class="sd">          will be None. If the classifier is using only 1 cpu, the profile will</span>
<span class="sd">          be &#39;threads-n&#39; with n = n_cpus.</span>
<span class="sd">        - **n_cpus**: The number of cpus used in the classifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#: Currently implemented classifiers:</span>
    <span class="n">__IMPLEMENTED_CLFS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="s1">&#39;rdf&#39;</span><span class="p">,</span> <span class="s1">&#39;nn&#39;</span><span class="p">,</span> <span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="s1">&#39;tmva&#39;</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span>  <span class="c1"># make sure not to change the argument given</span>

    <span class="c1"># test if input is classifier, create dict</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clf&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">}</span>

    <span class="c1"># if clf is a string only, create dict with only the type specified</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">clf</span> <span class="ow">in</span> <span class="n">__IMPLEMENTED_CLFS</span><span class="p">,</span> <span class="s2">&quot;clf not implemented (yet. Make an issue;) )&quot;</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clf_type&#39;</span><span class="p">:</span> <span class="n">clf</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">:</span> <span class="p">{}}</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Wrong data format of classifier...&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_cpu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span>

    <span class="c1"># Warning if n_cpu of clf is bigger then n_cpu, but only if not None</span>
    <span class="n">suppress_cpu_warning</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">n_cpu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">suppress_cpu_warning</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">get_n_cpu</span><span class="p">(</span><span class="n">n_cpu</span><span class="p">)</span>

    <span class="c1"># if input is dict containing a clf, make sure it&#39;s a Sklearn one</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">)):</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
        <span class="n">clf_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">Classifier</span><span class="p">):</span>
            <span class="n">classifier</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">classifier</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">classifier</span>

        <span class="c1"># Test which classifier it is and get parallel_profile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">XGBoostClassifier</span><span class="p">):</span>
            <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">nthreads</span>
            <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;xgb&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">TheanetsClassifier</span><span class="p">):</span>
            <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;nn&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">TMVAClassifier</span><span class="p">):</span>
            <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;tmva&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">SklearnClassifier</span><span class="p">):</span>
            <span class="n">sub_clf</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">clf</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_clf</span><span class="p">,</span> <span class="n">RandomForestClassifier</span><span class="p">):</span>
                <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="n">sub_clf</span><span class="o">.</span><span class="n">n_jobs</span>
                <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;rdf&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_clf</span><span class="p">,</span> <span class="n">AdaBoostClassifier</span><span class="p">):</span>
                <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;ada&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_clf</span><span class="p">,</span> <span class="n">GradientBoostingClassifier</span><span class="p">):</span>
                <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;gb&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_clf</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">):</span>
                <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">clf_type</span> <span class="o">=</span> <span class="s1">&#39;knn&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_cpu_clf</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n_cpu_clf</span> <span class="o">&gt;</span> <span class="n">n_cpu</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">suppress_cpu_warning</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;n_cpu specified at make_clf() for clf &lt; n_cpu of clf </span><span class="se">\</span>
<span class="s2">                            given! is that what you want?&quot;</span><span class="p">)</span>
        <span class="n">n_cpu</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_cpu</span> <span class="o">/</span> <span class="n">n_cpu_clf</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_cpu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_cpu_clf</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;threads-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_cpu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_cpu_clf</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clf_name</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_NAME</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">clf_type</span><span class="p">,</span> <span class="s2">&quot;classifier&quot;</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">)</span>

    <span class="c1"># If we do not have a classifier, we have a config dict and need to create a clf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># find the clf_type and make sure it&#39;s an implemented one</span>
        <span class="k">if</span> <span class="s1">&#39;clf_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">imp_clf</span> <span class="ow">in</span> <span class="n">__IMPLEMENTED_CLFS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">imp_clf</span> <span class="ow">in</span> <span class="n">clf</span><span class="p">:</span>
                    <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp_clf</span>
                    <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="n">imp_clf</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;clf_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid classifier, not implemented&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clf</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span>
        <span class="n">default_clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">clf_type</span><span class="o">=</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">],</span>
            <span class="n">name</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_NAME</span><span class="p">[</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]],</span>
            <span class="n">config</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_CLF_CONFIG</span><span class="p">[</span><span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]],</span>
        <span class="p">)</span>

        <span class="n">clf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">default_clf</span><span class="p">,</span> <span class="o">**</span><span class="n">clf</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;xgb&#39;</span><span class="p">:</span>
            <span class="c1"># update config dict with parallel-variables and random state</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nthreads</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">XGBoostClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;tmva&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">TMVAClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;gb&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rdf&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ada&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">base_estimator</span><span class="o">=</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()),</span> <span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">(),</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rdf&#39;</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">SklearnClassifier</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
            <span class="n">serial_clf</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">use_gpu</span>
            <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">randint</span><span class="p">()))</span>
            <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">TheanetsClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">))</span>

        <span class="c1"># assign classifier to output dict</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf_tmp</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dict_only</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;clf&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">clf_tmp</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;clf_type&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span>
        <span class="c1"># add parallel information</span>
        <span class="k">if</span> <span class="n">serial_clf</span> <span class="ow">and</span> <span class="n">n_cpu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;threads-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_cpu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;n_cpu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_cpu</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="backward_feature_elimination"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.backward_feature_elimination">[docs]</a><span class="k">def</span> <span class="nf">backward_feature_elimination</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">clf</span><span class="o">=</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_feature_elimination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">max_difference_to_best</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">keep_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">take_target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Train and score on each feature subset, eliminating features backwards.</span>

<span class="sd">    To know, which features make a big impact on the training of the clf and</span>
<span class="sd">    which don&#39;t, there are several techniques to find out. The most reliable,</span>
<span class="sd">    but also cost-intensive one, is the recursive backward feature elimination.</span>
<span class="sd">    A classifier gets trained first on all the features and is validated with</span>
<span class="sd">    the KFold-technique and the ROC AUC. Then, a feature is removed and the</span>
<span class="sd">    classifier is trained and tested again. This is done for all features once.</span>
<span class="sd">    The feature where the auc drops the least is then removed and the next round</span>
<span class="sd">    starts from the beginning but with one feature less.</span>

<span class="sd">    The function ends either if:</span>

<span class="sd">    - no features are left</span>
<span class="sd">    - max_feature_elimination features have been eliminated</span>
<span class="sd">    - the time limit max_feature_elimination is reached</span>
<span class="sd">    - the difference between the most useless features auc and the best</span>
<span class="sd">      (the run done with all features in the beginning) is higher then</span>
<span class="sd">      max_difference_to_best</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data</span>
<span class="sd">    target_data : HEPDataStorage</span>
<span class="sd">        The target data</span>
<span class="sd">    features : list(str, str, str,...)</span>
<span class="sd">        List of strings containing the features/columns to be used for the</span>
<span class="sd">        hyper-optimization or feature selection.</span>
<span class="sd">    clf : str {&#39;xgb, &#39;rdf, &#39;erf&#39;, &#39;gb&#39;, &#39;ada&#39;, &#39;nn&#39;} or config-dict</span>
<span class="sd">        For possible options, see also :py:func:`~raredecay.ml_analysis.make_clf()`</span>
<span class="sd">    n_folds : int &gt; 1</span>
<span class="sd">        How many folds you want to split your data in when doing KFold-splits</span>
<span class="sd">        to measure the performance of the classifier.</span>
<span class="sd">    max_feature_elimination : int &gt;= 1 or str &quot;hhhh:mm&quot;</span>
<span class="sd">        How many features should be maximal eliminated before it stopps or</span>
<span class="sd">        how much time it can take (approximately) to do the elimination.</span>
<span class="sd">        If the time runs out before other criterias are true (no features left,</span>
<span class="sd">        max_difference to high...), it just returns the results so far.</span>
<span class="sd">    max_difference_to_best : float</span>
<span class="sd">        The maximum difference between the &quot;least worst&quot; features auc and the best</span>
<span class="sd">        (usually the one with all features) auc before it stopps.</span>

<span class="sd">        In other words, it only eliminates features until the elimination would</span>
<span class="sd">        lead to a roc auc lower by max_difference_to_best then the roc auc</span>
<span class="sd">        with all features (= highest roc auc).</span>
<span class="sd">    keep_features:</span>
<span class="sd">        A list of features that won&#39;t be eliminated. The algorithm does not</span>
<span class="sd">        test the metric if that feature were removed. This saves</span>
<span class="sd">        quite some time.</span>
<span class="sd">    take_target_from_data : boolean</span>
<span class="sd">        Old, will be removed. Use if target-data == None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        Return a dictionary containing the evaluation:</span>

<span class="sd">        - **&#39;roc_auc&#39;** : an ordered-dict with the feature that was removed and</span>
<span class="sd">          the roc auc evaluated without that feature.</span>
<span class="sd">        - **&#39;scores&#39;** : All the roc auc with every feature removed once.</span>
<span class="sd">          Basically a pandas DataFrame containing all results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize variables and setting defaults</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;backward&#39;</span>
    <span class="n">keep_features</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">keep_features</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">keep_features</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># means: no time measurement on the way</span>
    <span class="n">available_time</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># start timer if time-limit is given</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">max_feature_elimination</span> <span class="o">=</span> <span class="n">max_feature_elimination</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Wrong time-format. Has to be &#39;hhh...hhh:mm&#39; &quot;</span>
        <span class="n">available_time</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3600</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                          <span class="mi">60</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_feature_elimination</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error, start_time is &lt;= 0, will cause error later&quot;</span>

    <span class="n">save_fig_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_SAVE_FIG</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">save_fig_cfg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">meta_config</span><span class="o">.</span><span class="n">warning_occured</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Feature not specified as argument to optimize_hyper_parameters.&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;Features for feature-optimization will be taken from data.&quot;</span><span class="p">)</span>
    <span class="c1"># We do not need to create more data than we well test on</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="n">features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">features</span> <span class="o">+</span> <span class="n">keep_features</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">features</span> <span class="o">!=</span> <span class="p">[],</span> <span class="s2">&quot;No features for optimization found&quot;</span>

    <span class="c1"># initialize data</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                      <span class="n">target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">)</span>

    <span class="c1"># initialize clf and parallel_profile</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
    <span class="n">clf_name</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">parallel_profile</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span>

<span class="c1"># ==============================================================================</span>
<span class="c1"># start backward feature elimination</span>
<span class="c1"># ==============================================================================</span>
    <span class="n">selected_features</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>  <span class="c1"># explicit is better than implicit</span>
    <span class="n">selected_features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">selected_features</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_features</span><span class="p">]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Need more then one feature to perform feature selection&quot;</span>

    <span class="c1"># starting feature selection</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Performing feature selection with the classifier&quot;</span><span class="p">,</span>
                    <span class="n">clf_name</span><span class="p">,</span> <span class="s2">&quot;of the features&quot;</span><span class="p">,</span> <span class="n">features</span><span class="p">],</span>
                   <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature selection: Recursive backward elimination&quot;</span><span class="p">)</span>
    <span class="n">original_clf</span> <span class="o">=</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span>
                                     <span class="n">stratified</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">use_stratified_folding</span><span class="p">,</span>
                                     <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">)</span>

    <span class="c1"># &quot;loop-initialization&quot;, get score for all features</span>
    <span class="n">roc_auc</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({})</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">feature</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">selected_features</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">original_clf</span><span class="p">)</span>  <span class="c1"># required, feature attribute can not be changed somehow</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">test_on</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">max_auc</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">roc_auc</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="s1">&#39;all features&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">max_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;feature importance &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="c1"># HACK: temp_plotter1 is used to set the plot.new_plot to False,</span>
        <span class="c1"># which is set to True (unfortunately) in the init of GridPlot</span>
        <span class="n">temp_plotter1</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">feature_importance_shuffling</span><span class="p">()</span>
        <span class="n">temp_plotter1</span><span class="o">.</span><span class="n">new_plot</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">temp_plotter1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature importance shuffling of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">))</span>
        <span class="c1"># HACK END</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;feature correlation &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">features_correlation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;ROC curve &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">roc</span><span class="p">(</span><span class="n">physics_notion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Learning curve &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_name</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">learning_curve</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">steps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric_label</span><span class="o">=</span><span class="s2">&quot;ROC AUC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

        <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">max_feature_elimination</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># eliminate all except one</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_feature_elimination</span><span class="p">])</span>

    <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for the timing</span>
    <span class="c1"># do-while python-style (with if-break inside)</span>
    <span class="k">while</span> <span class="n">n_to_eliminate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># initialize variable</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># a surely big initialisation</span>
        <span class="n">n_to_eliminate</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">n_features_left</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span>
        <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_features_left</span><span class="p">)</span>

        <span class="c1"># iterate through the features and remove the ith each time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">selected_features</span><span class="p">):</span>
            <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">original_clf</span><span class="p">)</span>  <span class="c1"># otherwise feature attribute trouble</span>
            <span class="n">temp_features</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">temp_features</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># remove ith feature for testing</span>
            <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">temp_features</span> <span class="o">+</span> <span class="n">keep_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">test_on</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">temp_features</span> <span class="o">+</span> <span class="n">keep_features</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">temp_auc</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">collected_scores</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">temp_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># set time condition, extrapolate assuming same time for each iteration</span>
            <span class="n">eet_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iterations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">iterations</span>
            <span class="k">if</span> <span class="n">available_time</span> <span class="o">&lt;</span> <span class="n">eet_next</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">max_auc</span> <span class="o">-</span> <span class="n">temp_auc</span> <span class="o">&lt;</span> <span class="n">difference</span><span class="p">:</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">max_auc</span> <span class="o">-</span> <span class="n">temp_auc</span>
                <span class="n">temp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">feature</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">temp_auc</span><span class="p">,</span> <span class="mi">4</span><span class="p">)}</span>

        <span class="k">if</span> <span class="n">difference</span> <span class="o">&gt;=</span> <span class="n">max_difference_to_best</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">roc_auc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp_dict</span><span class="p">)</span>
            <span class="n">selected_features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max_auc</span> <span class="o">=</span> <span class="n">temp_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># set time condition</span>
            <span class="k">if</span> <span class="n">available_time</span> <span class="o">&lt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_to_eliminate</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;roc_auc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">roc_auc</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">missing_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">collected_scores</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">missing_values</span><span class="p">)</span>
    <span class="n">temp_val</span> <span class="o">=</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;features_tot&#39;</span><span class="p">)</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;auc w/o &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected_scores</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">collected_scores</span><span class="p">[</span><span class="s1">&#39;features_tot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_val</span>
    <span class="n">collected_scores</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">collected_scores</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;The collected scores:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+</span>
                   <span class="p">[</span><span class="n">collected_scores</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">collected_scores</span><span class="p">],</span>
                   <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;scores&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collected_scores</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">difference</span> <span class="o">&gt;=</span> <span class="n">max_difference_to_best</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Stopped because difference in roc auc to best was &quot;</span><span class="p">,</span>
                        <span class="s2">&quot;higher then max_difference_to_best&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Next feature would have been: &quot;</span><span class="p">,</span> <span class="n">temp_dict</span><span class="p">],</span>
                       <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Feature elimination stopped because&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;max_feature_elimination was reached&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;(max number of eliminations or time limit).&quot;</span><span class="p">],</span>
                       <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span>
    <span class="c1"># if all features were removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Removed features and roc auc: &quot;</span><span class="p">,</span> <span class="n">roc_auc</span><span class="p">,</span>
                        <span class="s2">&quot;All features removed, loop stopped removing because no feature was left&quot;</span><span class="p">],</span>
                       <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Feature selection results&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="optimize_hyper_parameters"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.optimize_hyper_parameters">[docs]</a><span class="k">def</span> <span class="nf">optimize_hyper_parameters</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">n_eval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_checks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">generator_type</span><span class="o">=</span><span class="s1">&#39;subgrid&#39;</span><span class="p">,</span>
                              <span class="n">take_target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimize the hyperparameters of a classifiers.</span>

<span class="sd">    Hyper-parameter optimization of a classifier is an important task.</span>
<span class="sd">    Two datasets are required as well as a clf (not an instance, a dict).</span>
<span class="sd">    For more information about which classifiers are valid, see also</span>
<span class="sd">    :py:func:`~raredecay.analysis.ml_analysis.make_clf()`.</span>

<span class="sd">    The optimization does not happen automatic but checks the hyper-parameter</span>
<span class="sd">    space provided. Every clf-parameter that is a list or numpy array is</span>
<span class="sd">    considered a point. The search-technique can be specified under</span>
<span class="sd">    *generator_type*.</span>

<span class="sd">    It is possible to set a time limit instead of a n_eval limit. It estimates</span>
<span class="sd">    the time needed for a run and extrapolates. This extrapolation is not too</span>
<span class="sd">    precise, it can be at *worst* plus approximately 20% of allowed run-time,</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data</span>
<span class="sd">    target_data : HEPDataStorage</span>
<span class="sd">        The target data</span>
<span class="sd">    clf : config-dict</span>
<span class="sd">        For possible options, see also</span>
<span class="sd">        :py:func:`~raredecay.analysis.ml_analysis.make_clf()`.</span>
<span class="sd">        The difference is, for the feature you want to have optimised, use an</span>
<span class="sd">        iterable instead of a single value, e.g. &#39;n_estimators&#39;: [1, 2, 3, 4] etc.</span>
<span class="sd">    features : list(str, str, str,...)</span>
<span class="sd">        List of strings containing the features/columns to be used for the</span>
<span class="sd">        hyper-optimization.</span>
<span class="sd">    n_eval : int &gt; 1 or str &quot;hh...hh:mm&quot;</span>
<span class="sd">        How many evaluations should be done; how many points in the</span>
<span class="sd">        hyperparameter-space should be tested. This can either be an integer,</span>
<span class="sd">        which then represents the number of evaluations done or a string in the</span>
<span class="sd">        format of &quot;hours:minutes&quot; (e.g. &quot;3:25&quot;, &quot;1569:01&quot; (quite long...),</span>
<span class="sd">        &quot;0:12&quot;), which represents the approximat time it should take for the</span>
<span class="sd">        hyperparameter-search (**not** the exact upper limit)</span>
<span class="sd">    n_checks : 1 &lt;= int &lt;= n_folds</span>
<span class="sd">        Number of checks on *each* KFolded dataset will be done. For example,</span>
<span class="sd">        you split your data into 10 folds, but may only want to train/test on</span>
<span class="sd">        3 different ones.</span>
<span class="sd">    n_folds : int &gt; 1</span>
<span class="sd">        How many folds you want to split your data in when doing train/test</span>
<span class="sd">        sets to measure the performance of the classifier.</span>
<span class="sd">    generator_type : str {&#39;subgrid&#39;, &#39;regression&#39;, &#39;random&#39;}</span>
<span class="sd">        The generator searches the hyper-parameter space. Different generators</span>
<span class="sd">        can be used using different strategies to search for the global maximum.</span>

<span class="sd">        - **subgrid** : For larger grids, first performe search on smaller</span>
<span class="sd">          subgrids to better know the rough topology of the space.</span>
<span class="sd">        - **regression** : using an estimator doing regression on the already</span>
<span class="sd">          known hyper-parameter space points to estimate where to test for</span>
<span class="sd">          the next one.</span>
<span class="sd">        - **random** : Randomly choose points in the hyper-parameter space.</span>
<span class="sd">    take_target_from_data : Boolean</span>
<span class="sd">        |take_target_from_data_docstring|</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize variables and setting defaults</span>
<span class="c1">#    output = {}</span>
<span class="c1">#    save_fig_cfg = dict(meta_config.DEFAULT_SAVE_FIG, **cfg.save_fig_cfg)</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">,</span> <span class="n">dict_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">config_clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span>
    <span class="n">config_clf_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config_clf</span><span class="p">)</span>

    <span class="c1"># Create parameter for clf and hyper-search</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">columns</span>

    <span class="n">grid_param</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># parameters which are by their nature a list, e.g. nn-layers</span>
    <span class="n">list_param</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">,</span> <span class="s1">&#39;trainers&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_clf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_param</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">grid_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1"># count maximal combinations of parameters</span>
    <span class="n">max_eval</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">n_params</span> <span class="ow">in</span> <span class="n">grid_param</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
        <span class="n">max_eval</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_params</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Maximum possible evaluations: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_eval</span><span class="p">))</span>

    <span class="c1"># get a time estimation and extrapolate to get n_eval</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">max_eval</span><span class="p">):</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="n">n_eval</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_eval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Wrong time-format. Has to be &#39;hhh...hhh:mm&#39; &quot;</span>
        <span class="n">available_time</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_eval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_eval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">start_timer_test</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">min_elapsed_time</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mf">0.005</span> <span class="o">*</span> <span class="n">available_time</span>  <span class="c1"># to get an approximate extrapolation</span>
        <span class="n">n_eval_tmp</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span>
        <span class="n">n_checks_tmp</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># time will be multiplied by actual n_checks</span>

        <span class="c1"># call hyper_optimization with parameters for &quot;one&quot; run and measure time</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">data_out</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Starting small test-run for time estimation.&quot;</span><span class="p">,</span>
                       <span class="n">importance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># do-while loop</span>
        <span class="n">clf_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span>
        <span class="n">clf_tmp</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf_cp</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">start_timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="n">optimize_hyper_parameters</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="n">target_data</span><span class="p">,</span> <span class="n">clf</span><span class="o">=</span><span class="n">clf_tmp</span><span class="p">,</span>
                                      <span class="n">n_eval</span><span class="o">=</span><span class="n">n_eval_tmp</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span> <span class="n">n_checks</span><span class="o">=</span><span class="n">n_checks_tmp</span><span class="p">,</span>
                                      <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">generator_type</span><span class="o">=</span><span class="n">generator_type</span><span class="p">,</span>
                                      <span class="n">take_target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">,</span> <span class="n">time_test</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_timer</span>
            <span class="k">if</span> <span class="n">elapsed_time</span> <span class="o">&gt;</span> <span class="n">min_elapsed_time</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">n_checks_tmp</span> <span class="o">&lt;</span> <span class="n">n_checks</span><span class="p">:</span>  <span class="c1"># for small datasets, increase n_checks for testing</span>
                <span class="n">n_checks_tmp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_checks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_elapsed_time</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if time to small, increase n_rounds</span>
                <span class="n">n_eval_tmp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_elapsed_time</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">)</span>

        <span class="n">elapsed_time</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_checks</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_checks_tmp</span><span class="p">)</span>  <span class="c1"># time for &quot;one round&quot;</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_timer_test</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="p">((</span><span class="nb">int</span><span class="p">((</span><span class="n">available_time</span> <span class="o">*</span> <span class="mf">0.98</span> <span class="o">-</span> <span class="n">test_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">elapsed_time</span><span class="p">))</span> <span class="o">*</span>
                  <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n_eval_tmp</span><span class="p">)))</span>  <span class="c1"># we did just one</span>
        <span class="k">if</span> <span class="n">n_eval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_eval</span> <span class="o">=</span> <span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Time for one round:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;sec.&quot;</span><span class="p">,</span>
                        <span class="s2">&quot; Number of evaluations:&quot;</span><span class="p">,</span> <span class="n">n_eval</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="n">max_eval</span>

    <span class="n">n_eval</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_eval</span><span class="p">,</span> <span class="n">max_eval</span><span class="p">)</span>

    <span class="c1"># We do not need to create more data than we well test on</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">grid_param</span> <span class="o">!=</span> <span class="p">{},</span> <span class="s2">&quot;No values for optimization found&quot;</span>

    <span class="c1"># initialize data</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                      <span class="n">target_from_data</span><span class="o">=</span><span class="n">take_target_from_data</span><span class="p">)</span>

    <span class="c1"># initialize classifier</span>
    <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_clf</span>
    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf_dict</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">n_cpu_max</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
    <span class="n">clf_name</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">parallel_profile</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">]</span>

    <span class="c1"># rederict print output (for the hyperparameter-optimizer from rep)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s2">&quot;Starting hyper-optimization. This might take a while, no &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;output will be displayed during the process&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">IO_to_string</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;regression&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">RegressionParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;subgrid&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">SubgridParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">generator_type</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">RandomParameterOptimizer</span><span class="p">(</span><span class="n">grid_param</span><span class="p">,</span> <span class="n">n_evaluations</span><span class="o">=</span><span class="n">n_eval</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; not a valid, implemented generator&quot;</span><span class="p">)</span>
    <span class="n">scorer</span> <span class="o">=</span> <span class="n">FoldingScorer</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">,</span> <span class="n">fold_checks</span><span class="o">=</span><span class="n">n_checks</span><span class="p">)</span>
    <span class="n">grid_finder</span> <span class="o">=</span> <span class="n">GridOptimalSearchCV</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">scorer</span><span class="p">,</span> <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">)</span>

    <span class="c1"># Search for hyperparameters</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;starting &quot;</span> <span class="o">+</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyper optimization&quot;</span><span class="p">)</span>
    <span class="n">grid_finder</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyper optimization finished&quot;</span><span class="p">)</span>
    <span class="n">grid_finder</span><span class="o">.</span><span class="n">params_generator</span><span class="o">.</span><span class="n">print_results</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">out</span><span class="o">.</span><span class="n">IO_to_sys</span><span class="p">(</span><span class="n">subtitle</span><span class="o">=</span><span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; hyperparameter/feature optimization&quot;</span><span class="p">,</span>
                      <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">IO_to_sys</span><span class="p">(</span><span class="n">importance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="classify"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.classify">[docs]</a><span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="n">original_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
             <span class="n">clf</span><span class="o">=</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span> <span class="n">extended_report</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_predictions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">plot_title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">curve_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">plot_importance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
             <span class="n">target_from_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Training and/or testing a classifier or kfolded predictions.</span>

<span class="sd">    Classify is a multi-purpose function which does most of the things around</span>
<span class="sd">    machine-learning. It can be used for:</span>

<span class="sd">    - Training a clf.</span>
<span class="sd">        A quite simple task. You give some data, specify a clf and set</span>
<span class="sd">        validation to False (not mandatory actually, but pay attention if</span>
<span class="sd">        validation is set to an integer)</span>
<span class="sd">    - Predict data.</span>
<span class="sd">        Use either a pre-trained (see above) classifier or specify one with a</span>
<span class="sd">        string and give in some data to the validation and no to the</span>
<span class="sd">        original_data or target_data. Set get_predictions to True and you&#39;re</span>
<span class="sd">        done.</span>
<span class="sd">    - Get a ROC curve of two datasets with K-Folding.</span>
<span class="sd">        Specify the two input data (original_data and target_data) and use</span>
<span class="sd">        cross-validation by setting validation to the number of folds</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_data : HEPDataStorage</span>
<span class="sd">        The original data for the training</span>
<span class="sd">    target_data : HEPDataStorage or None</span>
<span class="sd">        The target data for the training. If None, only the original_data will</span>
<span class="sd">        be used for the training.</span>
<span class="sd">    features : list(str, str, str...)</span>
<span class="sd">        List with features/columns to use in training.</span>
<span class="sd">    validation : int &gt;= 1 or HEPDataStorage</span>
<span class="sd">        You can either do cross-validation or give a testsample for the data.</span>

<span class="sd">        * Cross-validation:</span>
<span class="sd">            Enter an integer, which is the number of folds</span>
<span class="sd">        * Validation-dataset:</span>
<span class="sd">            Enter a *HEPDataStorage* which contains data to be tested on.</span>
<span class="sd">            The target-label will be taken from it, so ensure that they are</span>
<span class="sd">            not None! To use two datasets, you can also use a list of</span>
<span class="sd">            **maximum** two datastorages.</span>
<span class="sd">    clf : classifier, see :py:func:`~raredecay.analysis.ml_analysis.make_clf()`</span>
<span class="sd">        The classifier to be used for the training and predicting. It can also</span>
<span class="sd">        be a pretrained classifier as argument.</span>
<span class="sd">    extended_report : boolean</span>
<span class="sd">        If True, make extended reports on the classifier as well as on the data,</span>
<span class="sd">        including feature correlation, feature importance etc.</span>
<span class="sd">    get_predictions : boolean</span>
<span class="sd">        If True, return a dictionary containing the prediction probabilities, the</span>
<span class="sd">        true y-values, weights and more. Have a look at the return values.</span>
<span class="sd">    plot_title : str</span>
<span class="sd">        A part of the title of the plots and general name of the call. Will</span>
<span class="sd">        also be printed in the output to identify with the intention this</span>
<span class="sd">        function was called.</span>
<span class="sd">    curve_name : str</span>
<span class="sd">        A labeling for the plotted data.</span>
<span class="sd">    weights_ratio : int &gt;= 0</span>
<span class="sd">        The ratio of the weights, actually the class-weights.</span>
<span class="sd">    importance : |importance_type|</span>
<span class="sd">        |importance_docstring|</span>
<span class="sd">    plot_importance : |plot_importance_type|</span>
<span class="sd">        |plot_importance_docstring|</span>
<span class="sd">    target_from_data : boolean</span>
<span class="sd">        |take_target_from_data_docstring|</span>

<span class="sd">    additional kwargs arguments :</span>
<span class="sd">        original_test_weights : pandas Series</span>
<span class="sd">            Weights for the test sample if you don&#39;t want to use the same</span>
<span class="sd">            weights as in the training</span>
<span class="sd">        target_test_weights : pandas Series</span>
<span class="sd">            Weights for the test sample if you don&#39;t want to use the same</span>
<span class="sd">            weights as in the training</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : clf</span>
<span class="sd">        Return the trained classifier.</span>
<span class="sd">    .. note::</span>
<span class="sd">        If validation was choosen to be KFold, the returned classifier well be</span>
<span class="sd">        instance of :py:class:`~rep.metaml.folding.FoldingClassifier()`!</span>
<span class="sd">    out : float (only if validation is not None)</span>
<span class="sd">        Return the score (recall or roc auc) of the validation. If only one</span>
<span class="sd">        class (sort of labels, mostly if data for validation is provided) is</span>
<span class="sd">        given, the recall will be computed. Otherwise the ROC-AUC (like for</span>
<span class="sd">        cross-validation)</span>
<span class="sd">    out : dict  (only if *get_predictions* is True)</span>
<span class="sd">        Return a dict containing the predictions, probability and more.</span>

<span class="sd">        - &#39;y_pred&#39; : predictions of the classifier</span>
<span class="sd">        - &#39;y_proba&#39; : prediciton probabilities</span>
<span class="sd">        - &#39;y_true&#39; : the true labels of the data (if available)</span>
<span class="sd">        - &#39;weights&#39; : the weights of the corresponding predicitons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting classify with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf</span><span class="p">))</span>
    <span class="n">VALID_KWARGS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;original_test_weights&#39;</span><span class="p">,</span> <span class="s1">&#39;target_test_weights&#39;</span><span class="p">]</span>

    <span class="c1"># initialize variables and data</span>
    <span class="n">save_fig_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">meta_config</span><span class="o">.</span><span class="n">DEFAULT_SAVE_FIG</span><span class="p">,</span> <span class="o">**</span><span class="n">cfg</span><span class="o">.</span><span class="n">save_fig_cfg</span><span class="p">)</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">make_plot</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># used if no validation</span>
    <span class="n">valid_input</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">VALID_KWARGS</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_input</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid kwargs:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_KWARGS</span><span class="p">]))</span>

    <span class="n">plot_title</span> <span class="o">=</span> <span class="s2">&quot;classify&quot;</span> <span class="k">if</span> <span class="n">plot_title</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">plot_title</span>

    <span class="k">if</span> <span class="n">original_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
                                          <span class="n">weights_ratio</span><span class="o">=</span><span class="n">weights_ratio</span><span class="p">,</span>
                                          <span class="n">target_from_data</span><span class="o">=</span><span class="n">target_from_data</span><span class="p">)</span>
        <span class="n">data_name</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">target_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_name</span> <span class="o">+=</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">target_data</span><span class="o">.</span><span class="n">name</span>

    <span class="n">clf_dict</span> <span class="o">=</span> <span class="n">make_clf</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_cpu</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="p">[</span><span class="s1">&#39;clf&#39;</span><span class="p">]</span>
    <span class="n">clf_name</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">parallel_profile</span> <span class="o">=</span> <span class="n">clf_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parallel_profile&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">and</span> <span class="n">validation</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;original_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s1">&#39;target_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="k">if</span> <span class="s1">&#39;original_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">temp_original_weights</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
                <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;original_test_weights&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="s1">&#39;target_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">temp_target_weights</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
                <span class="n">target_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target_test_weights&#39;</span><span class="p">))</span>
            <span class="n">test_weights</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">second_storage</span><span class="o">=</span><span class="n">target_data</span><span class="p">,</span>
                                                     <span class="n">normalization</span><span class="o">=</span><span class="n">weights_ratio</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;original_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">original_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_original_weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;target_test_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">target_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">temp_target_weights</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">test_weights</span> <span class="o">=</span> <span class="n">weights</span>

        <span class="n">clf</span> <span class="o">=</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">validation</span><span class="p">),</span> <span class="n">parallel_profile</span><span class="o">=</span><span class="n">parallel_profile</span><span class="p">,</span>
                                <span class="n">stratified</span><span class="o">=</span><span class="n">meta_config</span><span class="o">.</span><span class="n">use_stratified_folding</span><span class="p">)</span>
        <span class="c1"># folding-&gt; same data for train and test</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">LabeledDataStorage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">test_weights</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">):</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">validation</span><span class="o">.</span><span class="n">get_LabeledDataStorage</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">features</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">validation</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">make_plot</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">clf_score</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">data_val</span><span class="p">,</span> <span class="n">target_val</span><span class="p">,</span> <span class="n">weights_val</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">validation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">validation</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lds_test</span> <span class="o">=</span> <span class="n">LabeledDataStorage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data_val</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target_val</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">weights_val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Validation method &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">validation</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; not a valid choice&quot;</span><span class="p">)</span>

    <span class="c1"># train the classifier</span>
    <span class="k">if</span> <span class="n">original_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="c1"># if error &quot;1 not in list&quot; or similar occurs: no valid targets (None?)</span>

    <span class="c1"># test the classifier</span>
    <span class="k">if</span> <span class="n">validation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">ClassificationReport</span><span class="p">({</span><span class="n">clf_name</span><span class="p">:</span> <span class="n">clf</span><span class="p">},</span> <span class="n">lds_test</span><span class="p">)</span>
        <span class="n">test_classes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()))</span>
        <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_classes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_classes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">clf_score</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">compute_metric</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">())</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;ROC AUC of &quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">curve_name</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">],</span>
                           <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Report of &quot;</span> <span class="o">+</span> <span class="n">plot_title</span><span class="p">,</span>
                           <span class="n">importance</span><span class="o">=</span><span class="n">importance</span><span class="p">)</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot;, AUC = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">)</span>
            <span class="n">binary_test</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">get_predictions</span><span class="p">:</span>
                <span class="c1"># TODO: DRY, now WET</span>
                <span class="n">y_true</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()</span>
                <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_proba&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_proba</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_pred&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_true&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_true</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">allow_nones</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;report&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span>

        <span class="k">elif</span> <span class="n">n_classes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># score returns accuracy; if only one label present, it is the same as recall</span>
            <span class="n">y_true</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_targets</span><span class="p">()</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">get_predictions</span><span class="p">:</span>
                <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_proba&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred_proba</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_pred&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_pred</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;y_true&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_true</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">allow_nones</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">predictions</span><span class="p">[</span><span class="s1">&#39;report&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="n">lds_test</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>
            <span class="n">clf_score</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">lds_test</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">w_test</span><span class="p">)</span>
            <span class="n">clf_score2</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">y_pred</span><span class="p">)</span>  <span class="c1"># , sample_weight=w_test)</span>
            <span class="n">class_rep</span> <span class="o">=</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">w_test</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">class_rep</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Classification report &quot;</span> <span class="o">+</span> <span class="n">clf_name</span><span class="p">,</span>
                           <span class="n">importance</span><span class="o">=</span><span class="n">importance</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;recall of&quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">curve_name</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">],</span>
                           <span class="n">importance</span><span class="o">=</span><span class="n">importance</span><span class="p">)</span>
            <span class="n">binary_test</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot;, recall = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;accuracy NO WEIGHTS! (just for curiosity):&quot;</span><span class="p">,</span> <span class="n">clf_name</span><span class="p">,</span>
                            <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">curve_name</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">clf_score2</span><span class="p">],</span> <span class="n">importance</span><span class="o">=</span><span class="n">importance</span><span class="p">,</span>
                           <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Report of classify: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">plot_name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multi-label classification not supported&quot;</span><span class="p">)</span>

    <span class="c1"># plots</span>

    <span class="k">if</span> <span class="n">make_plot</span><span class="p">:</span>  <span class="c1"># if no validation is given, don&#39;t make plots</span>
        <span class="k">if</span> <span class="n">curve_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_name</span> <span class="o">=</span> <span class="n">curve_name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">plot_name</span>
        <span class="n">report</span><span class="o">.</span><span class="n">prediction</span><span class="p">[</span><span class="n">plot_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">prediction</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">clf_name</span><span class="p">)</span>
        <span class="n">report</span><span class="o">.</span><span class="n">estimators</span><span class="p">[</span><span class="n">plot_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">estimators</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">clf_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binary_test</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">plot_title</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span>
                         <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">roc</span><span class="p">(</span><span class="n">physics_notion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">plot_title</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ROC curve of &quot;</span> <span class="o">+</span>
                                                 <span class="n">clf_name</span> <span class="o">+</span> <span class="s2">&quot; on data:&quot;</span> <span class="o">+</span>
                                                 <span class="n">data_name</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ROC AUC = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clf_score</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>  <span class="c1"># the fifty-fifty line</span>

            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="s2">&quot;Learning curve &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span>
                         <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">,</span> <span class="o">**</span><span class="n">save_fig_cfg</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">learning_curve</span><span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">RocAuc</span><span class="p">(),</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Learning curve of &quot;</span> <span class="o">+</span>
                                                                        <span class="n">plot_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># TODO: implement learning curve with tpr metric</span>
<span class="c1">#            out.save_fig(plt.figure(&quot;Learning curve&quot; + plot_name),</span>
<span class="c1">#                         importance=plot_importance, **save_fig_cfg)</span>
<span class="c1">#            report.learning_curve(metrics., steps=1).plot(title=&quot;Learning curve of &quot; + plot_name)</span>
        <span class="k">if</span> <span class="n">extended_report</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Feature importance shuffling of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span>
                             <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
                <span class="c1"># HACK: temp_plotter1 is used to set the plot.new_plot to False,</span>
                <span class="c1"># which is set to True (unfortunately) in the init of GridPlot</span>
                <span class="n">temp_plotter1</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">feature_importance_shuffling</span><span class="p">()</span>
                <span class="n">temp_plotter1</span><span class="o">.</span><span class="n">new_plot</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">temp_plotter1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature importance shuffling of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">)</span>
                <span class="c1"># HACK END</span>
                <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Feature correlation matrix of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span>
                             <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
                <span class="n">report</span><span class="o">.</span><span class="n">features_correlation_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Feature correlation matrix of &quot;</span> <span class="o">+</span>
                                                                <span class="n">plot_name</span><span class="p">)</span>
            <span class="n">label_dict</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">binary_test</span> <span class="k">else</span> <span class="p">{</span><span class="n">test_classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;validation data&quot;</span><span class="p">}</span>
            <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Predictiond pdf of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">prediction_pdf</span><span class="p">(</span><span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">labels_dict</span><span class="o">=</span><span class="n">label_dict</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Predictiond pdf of &quot;</span> <span class="o">+</span> <span class="n">plot_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clf_score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span>
    <span class="k">elif</span> <span class="n">get_predictions</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span><span class="p">,</span> <span class="n">clf_score</span><span class="p">,</span> <span class="n">predictions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">clf</span><span class="p">,</span> <span class="n">clf_score</span></div>


<div class="viewcode-block" id="reweight_train"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_train">[docs]</a><span class="k">def</span> <span class="nf">reweight_train</span><span class="p">(</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">real_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">reweighter</span><span class="o">=</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">reweight_saveas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">weights_mc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_real</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a trained reweighter from a (mc/real) distribution comparison.</span>

<span class="sd">    | Reweighting a distribution is a &quot;making them the same&quot; by changing the</span>
<span class="sd">      weights of the bins (instead of 1) for each event. Mostly, and therefore</span>
<span class="sd">      the naming, you want to change the mc-distribution towards the real one.</span>
<span class="sd">    | There are two possibilities</span>

<span class="sd">    * normal bins reweighting:</span>
<span class="sd">       divides the bins from one distribution by the bins of the other</span>
<span class="sd">       distribution. Easy and fast, but unstable and inaccurat for higher</span>
<span class="sd">       dimensions.</span>
<span class="sd">    * Gradient Boosted reweighting:</span>
<span class="sd">       uses several decision trees to reweight the bins. Slower, but more</span>
<span class="sd">       accurat. Very useful in higher dimensions.</span>
<span class="sd">       But be aware, that you can easily screw up things by overfitting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mc_data : |hepds_type|</span>
<span class="sd">        The Monte-Carlo data to compare with the real data.</span>
<span class="sd">    real_data : |hepds_type|</span>
<span class="sd">        Same as *mc_data* but for the real data.</span>
<span class="sd">    columns : list of strings</span>
<span class="sd">        The columns/features/branches you want to use for the reweighting.</span>
<span class="sd">    reweighter : {&#39;gb&#39;, &#39;bins&#39;}</span>
<span class="sd">        Specify which reweighter to be used.</span>

<span class="sd">        - **gb**: The GradientBoosted Reweighter from REP,</span>
<span class="sd">          :func:`~hep_ml.reweight.GBReweighter`</span>
<span class="sd">        - **bins**: The simple bins reweighter from REP,</span>
<span class="sd">          :func:`~hep_ml.reweight.BinsReweighter`</span>
<span class="sd">    reweight_saveas : string</span>
<span class="sd">        To save a trained reweighter in addition to return it. The value</span>
<span class="sd">        is the filepath + name.</span>
<span class="sd">    meta_cfg : dict</span>
<span class="sd">        Contains the parameters for the bins/gb-reweighter. See also</span>
<span class="sd">        :func:`~hep_ml.reweight.BinsReweighter` and</span>
<span class="sd">        :func:`~hep_ml.reweight.GBReweighter`.</span>
<span class="sd">    weights_mc : numpy.array [n_samples]</span>
<span class="sd">        Explicit weights for the Monte-Carlo data. Only specify if you don&#39;t</span>
<span class="sd">        want to use the weights in the *HEPDataStorage*.</span>
<span class="sd">    weights_real : numpy.array [n_samples]</span>
<span class="sd">        Explicit weights for the real data. Only specify if you don&#39;t</span>
<span class="sd">        want to use the weights in the *HEPDataStorage*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : object of type reweighter</span>
<span class="sd">        Reweighter is trained to the data. Can, for example,</span>
<span class="sd">        be used with :func:`~hep_ml.reweight.GBReweighter.predict_weights`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__REWEIGHT_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gb&#39;</span><span class="p">:</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;bins&#39;</span><span class="p">:</span> <span class="s1">&#39;Bins&#39;</span><span class="p">,</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span> <span class="s1">&#39;Bins&#39;</span><span class="p">}</span>

    <span class="c1"># check for valid user input</span>
    <span class="k">if</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">is_pickle</span><span class="p">(</span><span class="n">reweighter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">adv_return</span><span class="p">(</span><span class="n">reweighter</span><span class="p">,</span> <span class="n">save_name</span><span class="o">=</span><span class="n">reweight_saveas</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reweighter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">__REWEIGHT_MODE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reweighter invalid: &quot;</span> <span class="o">+</span> <span class="n">reweighter</span><span class="p">)</span>

    <span class="n">reweighter</span> <span class="o">=</span> <span class="n">__REWEIGHT_MODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reweighter</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="n">reweighter</span> <span class="o">+=</span> <span class="s1">&#39;Reweighter&#39;</span>

    <span class="c1"># logging and writing output</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Reweighter:&quot;</span><span class="p">,</span> <span class="n">reweighter</span><span class="p">,</span> <span class="s2">&quot;with config:&quot;</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="p">]</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Data used:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot; and &quot;</span><span class="p">,</span>
                   <span class="n">real_data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">columns used for the reweighter training:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                   <span class="n">columns</span><span class="p">],</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Training the reweighter&quot;</span><span class="p">,</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># use the intesection of both colomns</span>
        <span class="n">common_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mc_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">common_cols</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">real_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="o">!=</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="n">columns</span> <span class="o">!=</span> <span class="n">real_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No columns specified for reweighting, took intersection&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot; of both dataset, as it&#39;s columns are not equal.&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Therefore some columns were not used!&quot;</span><span class="p">)</span>
            <span class="n">meta_config</span><span class="o">.</span><span class="n">warning_occured</span><span class="p">()</span>

    <span class="c1"># create data</span>
    <span class="n">mc_data</span><span class="p">,</span> <span class="n">_t</span><span class="p">,</span> <span class="n">mc_weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                                         <span class="n">weights_original</span><span class="o">=</span><span class="n">weights_mc</span><span class="p">)</span>
    <span class="n">real_data</span><span class="p">,</span> <span class="n">_t</span><span class="p">,</span> <span class="n">real_weights</span> <span class="o">=</span> <span class="n">_make_data</span><span class="p">(</span><span class="n">real_data</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                                             <span class="n">weights_original</span><span class="o">=</span><span class="n">weights_real</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">_t</span>

    <span class="c1"># train the reweighter</span>
    <span class="k">if</span> <span class="n">meta_cfg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">meta_cfg</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">reweighter</span> <span class="o">==</span> <span class="s2">&quot;GBReweighter&quot;</span><span class="p">:</span>
        <span class="n">reweighter</span> <span class="o">=</span> <span class="n">hep_ml</span><span class="o">.</span><span class="n">reweight</span><span class="o">.</span><span class="n">GBReweighter</span><span class="p">(</span><span class="o">**</span><span class="n">meta_cfg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reweighter</span> <span class="o">==</span> <span class="s2">&quot;BinsReweighter&quot;</span><span class="p">:</span>
        <span class="n">reweighter</span> <span class="o">=</span> <span class="n">hep_ml</span><span class="o">.</span><span class="n">reweight</span><span class="o">.</span><span class="n">BinsReweighter</span><span class="p">(</span><span class="o">**</span><span class="n">meta_cfg</span><span class="p">)</span>
    <span class="n">reweighter</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">original</span><span class="o">=</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">real_data</span><span class="p">,</span>
                   <span class="n">original_weight</span><span class="o">=</span><span class="n">mc_weights</span><span class="p">,</span> <span class="n">target_weight</span><span class="o">=</span><span class="n">real_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">adv_return</span><span class="p">(</span><span class="n">reweighter</span><span class="p">,</span> <span class="n">save_name</span><span class="o">=</span><span class="n">reweight_saveas</span><span class="p">)</span></div>


<div class="viewcode-block" id="reweight_weights"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_weights">[docs]</a><span class="k">def</span> <span class="nf">reweight_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="p">,</span> <span class="n">reweighter_trained</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply reweighter to the data and (add +) return the weights.</span>

<span class="sd">    Can be seen as a wrapper for the</span>
<span class="sd">    :py:func:`~hep_ml.reweight.GBReweighter.predict_weights` method.</span>
<span class="sd">    Additional functionality:</span>
<span class="sd">     * Takes a trained reweighter as argument, but can also unpickle one</span>
<span class="sd">       from a file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reweight_data : |hepds_type|</span>
<span class="sd">        The data for which the reweights are to be predicted.</span>
<span class="sd">    reweighter_trained : (pickled) reweighter (*from hep_ml*)</span>
<span class="sd">        The trained reweighter, which predicts the new weights.</span>
<span class="sd">    columns : list(str, str, str,...)</span>
<span class="sd">        The columns to use for the reweighting.</span>
<span class="sd">    normalize : boolean or int</span>
<span class="sd">        If True, the weights will be normalized (scaled) to the value of</span>
<span class="sd">        normalize.</span>
<span class="sd">    add_weights_to_data : boolean</span>
<span class="sd">        If set to False, the weights will only be returned and not updated in</span>
<span class="sd">        the data (*HEPDataStorage*). If you want to use the data later on</span>
<span class="sd">        in the script with the new weights, set this value to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    out : :py:class:`~pd.Series`</span>
<span class="sd">        Return an instance of pandas Series of shape [n_samples] containing the</span>
<span class="sd">        new weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">normalize</span>

    <span class="n">reweighter_trained</span> <span class="o">=</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">try_unpickle</span><span class="p">(</span><span class="n">reweighter_trained</span><span class="p">)</span>
    <span class="n">new_weights</span> <span class="o">=</span> <span class="n">reweighter_trained</span><span class="o">.</span><span class="n">predict_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="o">.</span><span class="n">pandasDF</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">),</span>
                                                     <span class="n">original_weight</span><span class="o">=</span><span class="n">reweight_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>

    <span class="c1"># write to output</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Using the reweighter:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">reweighter_trained</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> to reweight &quot;</span><span class="p">,</span>
                    <span class="n">reweight_data</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalize</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">new_weights</span> <span class="o">*=</span> <span class="n">new_weights</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">new_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">normalize</span>
    <span class="n">new_weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new_weights</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">reweight_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">add_weights_to_data</span><span class="p">:</span>
        <span class="n">reweight_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_weights</span></div>


<div class="viewcode-block" id="reweight_Kfold"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.reweight_Kfold">[docs]</a><span class="k">def</span> <span class="nf">reweight_Kfold</span><span class="p">(</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">real_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                   <span class="n">reweighter</span><span class="o">=</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">meta_cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_reweights</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">score_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score_clf</span><span class="o">=</span><span class="s1">&#39;xgb&#39;</span><span class="p">,</span>
                   <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mcreweighted_as_real_score</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Kfold reweight the data by &quot;itself&quot; for *scoring* and hyper-parameters.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       Do NOT use for the real reweighting process! (except if you really want</span>
<span class="sd">       to reweight the data &quot;by itself&quot;)</span>


<span class="sd">    If you want to figure out the hyper-parameters for a reweighting process</span>
<span class="sd">    or just want to find out how good the reweighter works, you may want to</span>
<span class="sd">    apply this to the data itself. This means:</span>

<span class="sd">    - train a reweighter on mc/real</span>
<span class="sd">    - apply it to get new weights for mc</span>
<span class="sd">    - compare the mc/real distribution</span>

<span class="sd">    The problem arises with biasing your reweighter. As in classification</span>
<span class="sd">    tasks, where you split your data into train/test sets for Kfolds, you</span>
<span class="sd">    want to do the same here. Therefore:</span>

<span class="sd">    - split the mc data into (n_folds-1)/n_folds (training)</span>
<span class="sd">    - train the reweighter on the training mc/complete real (if</span>
<span class="sd">      mcreweighted_as_real_score is True, the real data will be folded too</span>
<span class="sd">      for unbiasing the score)</span>
<span class="sd">    - reweight the leftout mc test-fold</span>
<span class="sd">    - do this n_folds times</span>
<span class="sd">    - getting unbiased weights</span>

<span class="sd">    The parameters are more or less the same as for the</span>
<span class="sd">    :py:func:`~raredecay.analysis.ml_analysis.reweight_train` and</span>
<span class="sd">    :py:func:`~raredecay.analysis.ml_analysis.reweight_weights`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mc_data : |hepds_type|</span>
<span class="sd">        The Monte-Carlo data, which has to be &quot;fitted&quot; to the real data.</span>
<span class="sd">    real_data : |hepds_type|</span>
<span class="sd">        Same as *mc_data* but for the real data.</span>
<span class="sd">    columns : list of strings</span>
<span class="sd">        The columns/features/branches you want to use for the reweighting.</span>
<span class="sd">    n_folds : int &gt;= 1</span>
<span class="sd">        The number of folds to split the data. Usually, the more folds the</span>
<span class="sd">        &quot;better&quot; the reweighting (especially for small datasets).</span>
<span class="sd">        If n_folds = 1, the data will be reweighted directly and the benefit</span>
<span class="sd">        of Kfolds and the unbiasing *disappears*</span>

<span class="sd">    reweighter : {&#39;gb&#39;, &#39;bins&#39;}</span>
<span class="sd">        Specify which reweighter to use.</span>
<span class="sd">        - **gb**: GradientBoosted Reweighter from REP</span>
<span class="sd">        - **bins**: Binned Reweighter from REP</span>
<span class="sd">    meta_cfg : dict</span>
<span class="sd">        Contains the parameters for the bins/gb-reweighter. See also</span>
<span class="sd">        :func:`~hep_ml.reweight.BinsReweighter` and</span>
<span class="sd">        :func:`~hep_ml.reweight.GBReweighter`.</span>
<span class="sd">    n_reweights : int</span>
<span class="sd">        As the reweighting often yields different weights depending on random</span>
<span class="sd">        parameters like the splitting of the data, the new weights can be</span>
<span class="sd">        produced by taking the average of the weights over many reweighting</span>
<span class="sd">        runs. n_reweights is the number of reweight runs to average over.</span>
<span class="sd">    score_columns : list(str, str, str,...)</span>
<span class="sd">        The columns to use for the scoring. It is often a good idea to use</span>
<span class="sd">        different (and more) columns for the scoring then for the reweighting</span>
<span class="sd">        itself. A good idea is to use the same columns as for the selection</span>
<span class="sd">        later on.</span>
<span class="sd">    score_clf : clf or clf-dict or str</span>
<span class="sd">        The classifier to be used for the scoring.</span>
<span class="sd">        Has to be a valid argument to</span>
<span class="sd">        :py:func:`~raredecay.analysis.ml_analysis.make_clf`.</span>
<span class="sd">    add_weights_to_data : boolean</span>
<span class="sd">        If True, the new weights will be added (in place) to the mc data and</span>
<span class="sd">        returned. Otherwise, the weights will only be returned.</span>
<span class="sd">    mcreweighted_as_real_score : boolean or str</span>
<span class="sd">        If a string, it has to be an implemented classifier in *classify*.</span>
<span class="sd">        If true, the default (&#39;xgb&#39; most probably) will be used.</span>
<span class="sd">        |</span>
<span class="sd">        If not False, calculate and print the score. This scoring is based on a</span>
<span class="sd">        clf, which was trained on the not reweighted mc and real data and</span>
<span class="sd">        tested on the reweighted mc, and then predicts how many it &quot;thinks&quot;</span>
<span class="sd">        are real datapoints.</span>
<span class="sd">        |</span>
<span class="sd">        Intuitively, a classifiers learns to distinguish between mc and real</span>
<span class="sd">        and then classifies mc reweighted data labeled as real; he says, how</span>
<span class="sd">        &quot;real&quot; the reweighted data looks like. So a higher score is better.</span>
<span class="sd">        Drawback of this method is, it is completely blind to over-fitting</span>
<span class="sd">        of the reweighter. To get a relation, the classifier also predicts</span>
<span class="sd">        the mc (which should be an under limit) as well as the real data</span>
<span class="sd">        (which should be an upper limit).</span>
<span class="sd">        |</span>
<span class="sd">        Even dough this scoring sais not a lot about how well the reweighting</span>
<span class="sd">        worked, we can say, that if the score is higher than the real one,</span>
<span class="sd">        it has somehow over-fitted (if a classifier cannot classify, say,</span>
<span class="sd">        more than 70% of the real data as real, it should not be able to</span>
<span class="sd">        classify more than 70% of the reweighted mc as real. Reweighted mc</span>
<span class="sd">        should not &quot;look more real&quot; than real data)</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    out : :py:class:`~pd.Series`</span>
<span class="sd">        Return the new weights.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Doing reweighting_Kfold with &quot;</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="s2">&quot; folds&quot;</span><span class="p">],</span>
                   <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Reweighting Kfold&quot;</span><span class="p">,</span> <span class="n">obj_separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># create variables</span>
    <span class="k">assert</span> <span class="n">n_folds</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_folds</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> \
        <span class="s2">&quot;n_folds has to be &gt;= 1, its currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">),</span> \
        <span class="s2">&quot;wrong data type. Has to be HEPDataStorage, is currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mc_data</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">real_data</span><span class="p">,</span> <span class="n">data_storage</span><span class="o">.</span><span class="n">HEPDataStorage</span><span class="p">),</span> \
        <span class="s2">&quot;wrong data type. Has to be HEPDataStorage, is currently&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">real_data</span><span class="p">))</span>

    <span class="n">new_weights_tot</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mc_data</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">mc_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">score_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">score_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">add_weights_to_data</span><span class="p">:</span>
        <span class="n">old_mc_tot_weights</span> <span class="o">=</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_reweights</span><span class="p">):</span>
        <span class="n">new_weights_all</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_weights_index</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># split data to folds and loop over them</span>
        <span class="n">mc_data</span><span class="o">.</span><span class="n">make_folds</span><span class="p">(</span><span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">real_data</span><span class="o">.</span><span class="n">make_folds</span><span class="p">(</span><span class="n">n_folds</span><span class="o">=</span><span class="n">n_folds</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data created, starting folding of run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s2">&quot; of total &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_reweights</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>

            <span class="c1"># create train/test data</span>
            <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">train_real</span><span class="p">,</span> <span class="n">test_real</span> <span class="o">=</span> <span class="n">real_data</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
                <span class="n">train_mc</span><span class="p">,</span> <span class="n">test_mc</span> <span class="o">=</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">train_real</span> <span class="o">=</span> <span class="n">test_real</span> <span class="o">=</span> <span class="n">real_data</span><span class="o">.</span><span class="n">get_fold</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
                <span class="n">train_mc</span> <span class="o">=</span> <span class="n">test_mc</span> <span class="o">=</span> <span class="n">mc_data</span>

            <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
                <span class="n">old_mc_weights</span> <span class="o">=</span> <span class="n">test_mc</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()</span>

            <span class="c1"># plot the first fold as example (the first one surely exists)</span>
            <span class="n">plot_importance1</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">fold</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">plot_importance1</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">run</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">train_real</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Reweighter trainer, example, fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span>
                                <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance1</span><span class="p">)</span>
                <span class="n">train_mc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;Reweighter trainer, example, fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span>
                              <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance1</span><span class="p">)</span>

            <span class="c1"># train reweighter on training data</span>
            <span class="n">reweighter_trained</span> <span class="o">=</span> <span class="n">reweight_train</span><span class="p">(</span><span class="n">mc_data</span><span class="o">=</span><span class="n">train_mc</span><span class="p">,</span>
                                                <span class="n">real_data</span><span class="o">=</span><span class="n">train_real</span><span class="p">,</span>
                                                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">reweighter</span><span class="o">=</span><span class="n">reweighter</span><span class="p">,</span>
                                                <span class="n">meta_cfg</span><span class="o">=</span><span class="n">meta_cfg</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reweighting fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;finished of run&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">))</span>

            <span class="n">new_weights</span> <span class="o">=</span> <span class="n">reweight_weights</span><span class="p">(</span><span class="n">reweight_data</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                                           <span class="n">reweighter_trained</span><span class="o">=</span><span class="n">reweighter_trained</span><span class="p">,</span>
                                           <span class="n">add_weights_to_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># fold only, not full data</span>
            <span class="c1"># plot one for example of the new weights</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Maximum of weights &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">new_weights</span><span class="p">))</span> <span class="o">+</span>
                         <span class="s2">&quot; of fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n_folds</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">plot_importance1</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="s2">&quot;new weights of fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">new_weights</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
                <span class="c1"># treat reweighted mc data as if it were real data target(1)</span>
                <span class="n">test_mc</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">train_mc</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">train_real</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># train clf on real and mc and see where it classifies the reweighted mc</span>
                <span class="n">clf</span><span class="p">,</span> <span class="n">tmp_score</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">train_mc</span><span class="p">,</span> <span class="n">train_real</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span>
                                          <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;mc reweighted as real&quot;</span><span class="p">,</span>
                                          <span class="n">features</span><span class="o">=</span><span class="n">score_columns</span><span class="p">,</span>
                                          <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;fold </span><span class="si">{}</span><span class="s2"> reweighted validation&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fold</span><span class="p">),</span>
                                          <span class="n">weights_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clf</span><span class="o">=</span><span class="n">score_clf</span><span class="p">,</span>
                                          <span class="n">importance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_importance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">scores</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp_score</span>

    <span class="c1"># Get the max and min for &quot;calibration&quot; of the possible score for the reweighted data by</span>
    <span class="c1"># passing in mc and label it as real (worst/min score) and real labeled as real (best/max)</span>
                <span class="n">test_mc</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">old_mc_weights</span><span class="p">)</span>
                <span class="n">_t</span><span class="p">,</span> <span class="n">tmp_score_min</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_mc</span><span class="p">,</span>
                                             <span class="n">features</span><span class="o">=</span><span class="n">score_columns</span><span class="p">,</span>
                                             <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;mc as real&quot;</span><span class="p">,</span>
                                             <span class="c1"># weights_ratio=1,</span>
                                             <span class="n">importance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_importance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">score_min</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp_score_min</span>
                <span class="n">test_real</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">_t</span><span class="p">,</span> <span class="n">tmp_score_max</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">validation</span><span class="o">=</span><span class="n">test_real</span><span class="p">,</span>
                                             <span class="n">features</span><span class="o">=</span><span class="n">score_columns</span><span class="p">,</span>
                                             <span class="n">curve_name</span><span class="o">=</span><span class="s2">&quot;real as real&quot;</span><span class="p">,</span>
                                             <span class="c1"># weights_ratio=1,</span>
                                             <span class="n">importance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_importance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">score_max</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp_score_max</span>
                <span class="k">del</span> <span class="n">_t</span>

            <span class="c1"># collect all the new weights to get a really cross-validated reweighted dataset</span>
            <span class="n">new_weights_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_weights</span><span class="p">)</span>
            <span class="n">new_weights_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_mc</span><span class="o">.</span><span class="n">get_index</span><span class="p">())</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;fold &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;finished&quot;</span><span class="p">)</span>
            <span class="c1"># end of for-loop</span>

        <span class="c1"># concatenate weights and index</span>
        <span class="k">if</span> <span class="n">n_folds</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_weights_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">)</span>
            <span class="n">new_weights_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_weights_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_weights_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">)</span>
            <span class="n">new_weights_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_weights_index</span><span class="p">)</span>
        <span class="n">new_weights_tot</span> <span class="o">+=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_weights_index</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Maximum of accumulated weights: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">new_weights_tot</span><span class="p">)))</span>

        <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;New weights of run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">),</span> <span class="n">importance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">hack_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_weights_all</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">hack_array</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;New weights of reweighting at end of run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">))</span>

    <span class="c1"># after for loop for weights creation</span>
    <span class="n">new_weights_tot</span> <span class="o">/=</span> <span class="n">n_reweights</span>

    <span class="k">if</span> <span class="n">add_weights_to_data</span><span class="p">:</span>
        <span class="n">mc_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">new_weights_tot</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mc_data</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">old_mc_tot_weights</span><span class="p">)</span>

    <span class="n">out</span><span class="o">.</span><span class="n">save_fig</span><span class="p">(</span><span class="n">figure</span><span class="o">=</span><span class="s2">&quot;New weights of total mc&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">new_weights_tot</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;New weights of reweighting with Kfold&quot;</span><span class="p">)</span>

    <span class="c1"># create score</span>
    <span class="k">if</span> <span class="n">mcreweighted_as_real_score</span><span class="p">:</span>
        <span class="n">scores</span> <span class="o">/=</span> <span class="n">n_reweights</span>
        <span class="n">score_min</span> <span class="o">/=</span> <span class="n">n_reweights</span>
        <span class="n">score_max</span> <span class="o">/=</span> <span class="n">n_reweights</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">subtitle</span><span class="o">=</span><span class="s2">&quot;Kfold reweight report&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                       <span class="n">section</span><span class="o">=</span><span class="s2">&quot;Precision scores of classification on reweighted mc&quot;</span><span class="p">)</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;Reweighted: &quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="s1">&#39;score_reweighted&#39;</span><span class="p">),</span>
                      <span class="p">(</span><span class="s2">&quot;mc as real (min): &quot;</span><span class="p">,</span> <span class="n">score_min</span><span class="p">,</span> <span class="s1">&#39;score_min&#39;</span><span class="p">),</span>
                      <span class="p">(</span><span class="s2">&quot;real as real (max): &quot;</span><span class="p">,</span> <span class="n">score_max</span><span class="p">,</span> <span class="s1">&#39;score_max&#39;</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">score_list</span><span class="p">:</span>
            <span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_output</span><span class="p">([</span><span class="s2">&quot;Classify the target, average score &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s2">&quot; +- &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">std</span><span class="p">)],</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>

    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_weights_tot</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="best_metric_cut"><a class="viewcode-back" href="../../../raredecay.analysis.ml_analysis.html#raredecay.analysis.ml_analysis.best_metric_cut">[docs]</a><span class="k">def</span> <span class="nf">best_metric_cut</span><span class="p">(</span><span class="n">mc_data</span><span class="p">,</span> <span class="n">real_data</span><span class="p">,</span> <span class="n">prediction_branch</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span>
                    <span class="n">plot_importance</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the best threshold cut for a given metric.</span>

<span class="sd">    Test the metric for every possible threshold cut and returns the highest</span>
<span class="sd">    value. Plots the metric versus cuts as well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mc_data : |hepds_type|</span>
<span class="sd">        The MC data</span>
<span class="sd">    real_data : |hepds_type|</span>
<span class="sd">        The real data</span>
<span class="sd">    prediction_branch : str</span>
<span class="sd">        The branch name containing the predictions to test.</span>
<span class="sd">    metric : str |implemented_primitive_metrics| or simple metric</span>
<span class="sd">        Can be a valid string pointing to a metric or a simple metric taking</span>
<span class="sd">        only tpr and fpr: metric(tpr, fpr, weights=None)</span>
<span class="sd">    plot_importance : |plot_importance_type|</span>
<span class="sd">        |plot_importance_docstring|</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    out : dict</span>
<span class="sd">        Return a dict containing the best threshold cut as well as the metric</span>
<span class="sd">        value. The keywords are:</span>

<span class="sd">            - **best_threshold_cut**: the best cut on the predictions</span>
<span class="sd">            - **best_metric**: the value of the metric when applying the best</span>
<span class="sd">              cut.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">rep.report.metrics</span> <span class="k">import</span> <span class="n">OptimalMetric</span>

    <span class="kn">from</span> <span class="nn">raredecay.tools.metrics</span> <span class="k">import</span> <span class="n">punzi_fom</span><span class="p">,</span> <span class="n">precision_measure</span>

    <span class="n">metric_name</span> <span class="o">=</span> <span class="n">metric</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;punzi&#39;</span><span class="p">:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">punzi_fom</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;precision&#39;</span><span class="p">:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">precision_measure</span>

    <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">(</span><span class="n">real_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">prediction_branch</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>
    <span class="n">metric_optimal</span> <span class="o">=</span> <span class="n">OptimalMetric</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

    <span class="n">best_cut</span><span class="p">,</span> <span class="n">best_metric</span> <span class="o">=</span> <span class="n">metric_optimal</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                   <span class="n">proba</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">sample_weight</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">metric_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; vs cut&quot;</span><span class="p">,</span> <span class="n">importance</span><span class="o">=</span><span class="n">plot_importance</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> vs cut of </span><span class="si">{1}</span><span class="s2"> and </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">metric_name</span><span class="p">),</span> <span class="n">real_data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mc_data</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">metric_optimal</span><span class="o">.</span><span class="n">plot_vs_cut</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">proba</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

    <span class="n">best_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">best_metric</span><span class="p">)</span>
    <span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">best_metric</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;best_threshold_cut&#39;</span><span class="p">:</span> <span class="n">best_cut</span><span class="p">[</span><span class="n">best_index</span><span class="p">],</span>
              <span class="s1">&#39;best_metric&#39;</span><span class="p">:</span> <span class="n">best_metric</span><span class="p">[</span><span class="n">best_index</span><span class="p">]}</span>

    <span class="k">return</span> <span class="n">output</span></div>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;main&quot;</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s1">&#39;test&#39;</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonas Eschle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.2.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>